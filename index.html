<!DOCTYPE html>
<html lang="fr">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=1024" />

    <title>Clojure Kisses</title>
    <meta name="description" content="Les fondements, innovants ou antédiluviens, qui font de Clojure un outil unique sur la JVM ! Kiss after kiss, une présentation des grandes idées et des petites attentions du langage." />
    <meta name="author" content="Cédric Pineau" />

    <link href="css/shCoreDefault.css" rel="stylesheet" type="text/css" /> <!--http://alexgorbatchev.com/pub/sh/current/styles/-->
    <script src="js/shCore.js" type="text/javascript"></script> <!--http://alexgorbatchev.com/pub/sh/current/scripts/-->
    <script src="js/shBrushClojure.js" type="text/javascript"></script>
    <script type="text/javascript">SyntaxHighlighter.all();</script>

    <link href="css/fonts.css" rel="stylesheet" /> <!--http://fonts.googleapis.com/css?family=Open+Sans:regular,semibold,italic,italicsemibold|PT+Sans:400,700,400italic,700italic|PT+Serif:400,700,400italic,700italic-->
    <link href="css/clojure-kisses.less" rel="stylesheet/less" type="text/css" />
    <script src="js/less-1.3.0.min.js" type="text/javascript"></script>
    <link href="img/favicon.png" rel="shortcut icon" />
</head>

<body class="impress-not-supported">

    <div class="fallback-message">
        <p>Your browser <b>doesn't support the features required</b> by impress.js, so you are presented with a simplified version of this presentation.</p>
        <p>For the best experience please use the latest <b>Chrome</b>, <b>Safari</b> or <b>Firefox</b> browser.</p>
    </div>

    <div id="impress">

        <div id="Accroche" class="step slide" data-x="0" data-y="-100">
            <br>
            <div class="centered">
                <img src="img/breizhcamp.png">
            </div>
            <br><br>
            <div class="centered">
                Les fondements, innovants ou antédiluviens, qui font de<br> 
                <big><strong>Clojure</strong></big><br>
                un outil unique sur la JVM !<br>
                Les grandes idées et les petites attentions du langage.
            </div>
        </div>

        <div id="Bonjour" class="step slide" data-x="80" data-y="-100">
            <br><br><br><br><br><br>
            <div class="centered">
                <pre class="brush: clojure;">
                    (println "Bonjour et bienvenus BreizhCampeurs !")
                </pre>
            </div>
        </div>

        <div id="Moi" class="step slide" data-x="160" data-y="-100">
            
            <div class="centered">
            
            <br>
            <br>
            Cédric Pineau<br>
            <br>
            Le libre / Debian<br>
            JVM<br>
            <br>
            <img src="img/followMe.png" width="8%"> cedricpineau<br>
            <br><br><br><br><br>
                <img src="img/anteo.jpg">
            </div>
            
        </div>

        <div id="What" class="step slide" data-x="240" data-y="-100">
            <br><br>
            <h1>Clo-<b>what ?</b></h1>
            <br><br>
            <ul>
                <li>Un LISP</li>
                <li>Sur la JVM !</li>
                <li>Axé sur la concurrence</li>
                <li>Qui embrasse le KISS</li>
            </ul>
        </div>

        <div id="Rich" class="step slide" data-x="320" data-y="-100">
            <br><br>
            <h1>KISS ?</b></h1>
            <br>
            <img src="img/richHickey.jpg">
            <br>
            <br>
            <div class="centered"><q>"Reducing incidental complexity is a primary focus of Clojure"</q></div>
        </div>

        <div id="Opensource" class="step slide" data-x="400" data-y="-100">
            <br><br><br>
            Un développement ouvert, sous licence Eclipse Public License<br>
            <br>
            70 développeurs sur la release 1.4<br>
            <br>
            Une grosse communauté : 
            <ul>
                <li>6500 personnes sur la mailing list</li>
                <li>plusieurs conférences dédiées : Clojure/West (San Jose), Clojure/Conj (Raleigh), Euroclojure (Londres), ..</li>
            </ul>
        </div>

        <div id="Promu1" class="step slide" data-x="480" data-y="-100">
            <br><br><br>
            <div class="centered">
                <img src="img/uncleBob.png">
            </div>
        </div>

        <div id="Promu2" class="step slide" data-x="560" data-y="-100">
            <div class="centered">
                ThoughtWorks Technology Radar de mars 2012
                <br><br>
                <img src="img/thoughtworks.png">
            </div>
        </div>

        <div id="lisp1" class="step slide" data-x="640" data-y="-100">
            <br><br>
            <h1>"Practical LISP on the JVM"</h1>
            <br>
            <ul>
                <li>Une syntaxe à base S-expression, une notation préfixée parenthésée</li>
                <li>Un REPL</li>
                <li>typage dynamique (mais fort)</li>
                <li>fonctionnel impur</li>
            </ul>
        </div>

        <div id="Syntaxe1" class="step slide" data-x="720" data-y="-100">
            <br><br>
            <h1>Lots of Irritating Superfluous Parenthesis !<br>(mais moins que LISP !)</h1>
            <br>
            <ul>
                <li>LISP aka LISt Processing. Le couple de parenthèses définit une liste.
                <li>mais éléments de syntaxe tel que les vecteurs [], les maps {}</li>
                <li>au final pas davantage de tokens de structuration que les autres langages</li>
            </ul>
        </div>

        <div id="Syntaxe2" class="step slide" data-x="800" data-y="-100">
            <br><br>
            <h1>Pourquoi une notation préfixée ?</h1>
            <ul>
                <li>Une syntaxe régulière, les opérateurs sont des fonctions</li>
                <li>Un nombre d'arguments variables : (+ 1 2 3)</li>
                <li>Pas de casse-tête de priorité d'opérateurs !</li>
            </ul>
            <br>
            <pre class="brush: clojure;">
            (+ (* 2 3) 1) ; 1 + 2 * 3
            ;=> 7
            </pre>
        </div>

        <div id="S-expression1" class="step slide" data-x="880" data-y="-100">
            <br>
            A l'inverse de nombreux langages, il n'existe pas de "Statement"<br>
            Tout est expression dont l'évaluation donne une valeur unique, même les constructions de type if, for, etc<br>
            <pre class="brush: clojure;">
            1
            ;= 1
            
            [1 2 3] ; Vecteur
            ;= [1 2 3]
            
            (println "Bonjour et bienvenus BreizhCampeurs !")
            ; Bonjour et bienvenus BreizhCampeurs !
            ;= nil
            
            (+ 1 2)  ; Appel de fonction
            ;= 3
            </pre>
        </div>

        <div id="S-expression2" class="step slide" data-x="960" data-y="-100">
            <br>
            La structure régulière facilite l'apprentissage du langage<br>
            <br>
            <pre class="brush: clojure;">
            (def a 1) ; int a = 1;
            ;= #'user/a 
            
            (inc a) ; a++; ou ++a; ou a+=1; ou a+1;
            ;= 2
            
            (if (odd? a) (/ a 2) a) ; a%2 != 0 ? a / 2 : a;
            ;= 1/2
            
            (defn square [x]
              "Met au carré"
              (* x x))
            ;= #'user/square
            </pre>
        </div>

        <div id="homoiconicité" class="step slide" data-x="1040" data-y="-100">
            <br><br>
            <h1>Homoiconicité<br>"Lisp programs are lisp data structures"</h1>
            <br>
            <ul>
                <li>Chaque S-expression est un literal ou une liste</li>
                <li>Facilite la création de mini-langages adaptés aux besoins : DSL</li>
                <li>Une grand partie du langage est défini à partir de macros !</li>
            </ul>
        </div>

        <div id="Macro1" class="step slide" data-x="1120" data-y="-100">
            <br><br>
            <h1>Exemple de la construction "with-open"</h1>
            <pre class="brush: clojure;">
            (with-open [r (java.io.FileReader. "myfile.txt")] 
              (loop [c (.read r)] 
                (if (not= c -1)
                  (do 
                    (print (char c)) 
                    (recur (.read r))))))
            </pre>
        </div>

        <div id="Macro2" class="step slide" data-x="1200" data-y="-100">
            <pre class="brush: clojure;">
            (defmacro with-open
              [bindings & body]
              (assert-args
                 (vector? bindings) "binding vector"
                 (even? (count bindings)) "even forms")
              (cond
                (= (count bindings) 0) 
                  `(do ~@body)
                (symbol? (bindings 0)) 
                  `(let ~(subvec bindings 0 2)
                    (try
                      (with-open ~(subvec bindings 2) ~@body)
                    (finally
                      (. ~(bindings 0) close))))
                :else (throw (IllegalArgumentException.
                  "only allows Symbols in bindings"))))
            </pre>
        </div>

        <div id="DSL1" class="step slide" data-x="1280" data-y="-100">
            <div class="centered">DSL : Enlive (HTML templating)</div>
            <br>
            <pre class="brush: clojure;">
            (defn home-page []
              (html
                [:head
                 (include-css "/static/site.css")
                 [:title *title*]]
                [:body 
                 [:a {:href "http://clj-la.org"} 
                  [:img {:id "logo" :src "logo.png"}]]
                 [:div {:class "header"} "Hi " (user-name)]
                 [:h1 *title*]
                 "URL: " [:input {:type "text" :id "url"}]
                 [:button {:id "shorten"} "Shorten"]
                 [:div {:id "short" :class "short"}]]
                 (include-js "/static/site.js")))
            </pre>
        </div>

        <div id="DSL2" class="step slide" data-x="1360" data-y="-100">
            <br><br>
            <h1>DSL : ClojureQL (SQL)</h1>
            <br>
            <pre class="brush: clojure;">
            (with-results [rs (table :customer)]
              (doseq [r rs] (println (:lastname r)))
            
            (conj! (table :customer) {:age 22})
            
            (conj! (table :customer) [{:age 22} {:age 23}])
            </pre>
        </div>

        <div id="Lisp2" class="step slide" data-x="1440" data-y="-100">
            <br><br>
            <h1>"Practical LISP on the JVM"</h1>
            <br>
            <q>
            "Lisp is a programmable programming language."<br>
            John Foderaro, CACM, September 1991<br>
            <br>
            "Lisp isn't a language, it's a building material."<br>
            Alan Kay
            </q>
            
        </div>

        <div id="REPL1" class="step slide" data-x="1520" data-y="-100">
            <div class="centered">La Read–Eval–Print Loop<br>Un outil de développement interactif</div>
            <!--
            <iframe src="http://tryclj.com/" width="100%" height="700">
              <p>Your browser does not support iframes.</p>
            </iframe>
            -->
        </div>

        <div id="REPL2" class="step slide" data-x="1600" data-y="-100">
            <br><br>
            <h1>user=> ??</h1>
            La modularité clojure repose sur l'utilisation d'espaces de nommage
            <br>
            <pre class="brush: clojure;">
            (ns ^{:doc "The core Clojure language."
                   :author "Rich Hickey"}
              clojure.core)
            ; <->
            (defn require
            ; <->
            (defn use
            </pre>
        </div>

        <div id="REPL3" class="step slide" data-x="1680" data-y="-100">
            On utilise require et use pour lier ou importer d'autres namespaces
            clojure.core et java.lang sont importés par défaut
            <pre class="brush: clojure;">
            (def input (java.io.StringReader.
                         "<?xml version=\"1.0\"?>
                          <foo>bar</foo>"))
            
            (require 'clojure.data.xml)
            (clojure.data.xml/parse input)
            ;= #clojure.data.xml.Element{:tag :foo, 
            ;=                           :attrs {},
            ;=                           :content ("bar")}
            
            (require '[clojure.data.xml :as xml])
            (xml/parse input)
            
            (use 'clojure.data.xml)
            (parse input)
            </pre>
        </div>

        <div id="REPL4" class="step slide" data-x="1760" data-y="-100">
            <br><br>
            <h1>Quelques fonctions utiles dans un REPL</h1>
            <pre class="brush: clojure;">
            (doc doc)
            ; -------------------------
            ; clojure.repl/doc
            ; ([name])
            ; Macro
            ;  Prints documentation for a var or special form 
            ;  given its name
            ;= nil
            </pre>
        </div>

        <div id="REPL5" class="step slide" data-x="1840" data-y="-100">
            <br><br>
            <h1>Quelques fonctions utiles dans un REPL</h1>
            <pre class="brush: clojure;">
            all-ns ; sequence de tous les namespaces
            ns-publics ; contenu public d'un namespace
            apropos ; recherche par regexp dans les noms
            find-doc ; recherche par regexp dans les docs
            source ; affiche les sources d'une fonction/macro
            pst ; affiche la stacktrace, *e pour la dernière
            javadoc ; charge la doc java demandée
            </pre>
            
        </div>

        <div id="Typage" class="step slide" data-x="1920" data-y="-100">
            <br><br>
            <h1>Un typage dynamique à la LISP mais fort à la Java</h1>
            <ul>
            <br>
                <li>Pas de conversion de type implicite à la Javascript/PHP
                <li>Des erreurs de types à l'exécution !</li>
            </ul>
            <br>
            <pre class="brush: clojure;">
            (+ 1 "2")
            ; ClassCastException java.lang.String 
            ; cannot be cast to java.lang.Number
            ; clojure.lang.Numbers.add (Numbers.java:126)
            </pre>
        </div>

        <div id="Types1" class="step slide" data-x="2000" data-y="-100">
            <div class="centered">Quels types ?</div>
            <br>
            <pre class="brush: clojure;">
            \A ; caractères, dont \o41 \u00ff \space, etc
            ;= \A
            "Bonjour BreizhCampeurs !" ; chaînes
            ;= "Bonjour BreizhCampeurs !"
            true ; booléens
            ; = true
            (+ 1 1/7) ; long, double, bigint/decimal + ratio
            ;= 8/7
            :pizza4all ; Keyword
            ;= :pizza4all
            (re-find #"\d+" "a123de") ; regexp
            ;= "123"
            nil ; équivalent du null java, vaut false 
            ;= nil
            </pre>
        </div>

        <div id="dataStructure1" class="step slide" data-x="2080" data-y="-100">
            <br>
            et un ensemble de structures de données :
            <pre class="brush: clojure;">
            ; Le vecteur, indexé 
            (get [1 2 3 4] 2)
            ;= 3
            
            ; Map
            ({:name "Clojure", :auteur "Rich Hickey"} :name)
            ;= "Clojure"
            
            ; Set
            (#{ \e \i \o \u} )
            ;= 
            
            ; Une liste (chainée simple)
            (second '( \e \i \o \u))
            ;= \e
            </pre>
        </div>

        <div id="dataStructure2" class="step slide" data-x="2160" data-y="-100">
            <br><br>
            Ces structures sont manipulées au travers de 7 abstractions :
            <br><br>
            <ul>
                <li>Collection</li>
                <li>Sequence</li> 
                <li>Associative</li>
                <li>Indexed</li>
                <li>Stack</li>
                <li>Set</li>
                <li>Sorted</li>
            </ul>
        </div>

        <div id="Collection1" class="step slide" data-x="2240" data-y="-100">
            <h1>Collection</h1>
            Toutes les structures de données clojure sont des collections
            <pre class="brush: clojure;">
            (def c (conj [] 1 2 3))
            ;= #'user/c
            c
            ;= [1 2 3]
            
            (count c)
            ;= 3
            
            (conj '(1 2) 3)
            ;= (3 1 2)
            
            (conj [1 2] 3)
            ;= [1 2 3]
            </pre>
        </div>

        <div id="Sequence1" class="step slide" data-x="2320" data-y="-100">
            <br>
            <h1>Sequence, une abstraction essentielle du langage</h1>
            <br>
            Toutes les Collections clojure et Java, les maps Java, les CharSequence (dont String), les Iterable, les Arrays et même nil sont des séquences.<br>
            <br>
            Concrètement un répertoire et un fichier sont des séquences, les enregistrements d'une table de BD forment une séquence, ..<br>
            <br>
            L'intérêt principal des sequences est l'<b>évaluation paresseuse</b>, et les <b>séquences infinies</b>
        </div>

        <div id="Sequence2" class="step slide" data-x="2400" data-y="-100">
            <br>
            <pre class="brush: clojure;">
            (cons 3 '(1 2)) ou (cons 3 [1 2])
            ;= (3 1 2)
            
            ; first, second, rest, last, butlast
            
            (defn random-ints [limit]
              (lazy-seq
                (cons (rand-int limit)
                      (random-ints limit))))
            ;= #'user/random-ints
            
            (take 10 (random-ints 50))
            ;= (49 5 2 30 35 27 16 17 6 16)
            </pre>
            <br>
            http://clojure.org/Sequences
        </div>

        <div id="Associative1" class="step slide" data-x="2480" data-y="-100">
            <h1>Associative</h1>
            <pre class="brush: clojure;">
            (def m (assoc {} :fname "Rich" :lname "Hickey"))
            ;= #'user/m
            (get m :lname) ; ou (m :lname) ou même (:lname m)
            ;= "Hickey"
            (get m :age "inconnu")
            ;= "inconnu"
            (dissoc m :fname :age)
            ;= {:lname "Hickey"}
            (contains? m :fname)
            ;= true  ; !?!
            (assoc [1 2 3 4] 2 15)
            ; [1 2 15 4]
            ; keys, vals, etc
            </pre>
        </div>

        <div id="Indexed1" class="step slide" data-x="2560" data-y="-100">
            <h1>Indexed</h1>
            <pre class="brush: clojure;">
            (def v [:a :b :c])
            ;= #'user/v
            
            (nth v 2) ; ou (v 2) car v est "Associative" !
            ;= :c
            (nth v 3)
            ;= IndexOutOfBoundsException ..
            (nth v 3 0) ; possibilité de valeur par défaut
            ;= 0
            (get v 3)
            ;= nil
            (get :?? 3)
            ;= nil
            </pre>
        </div>

        <div id="Stack" class="step slide" data-x="2640" data-y="-100">
            <h1>Stack</h1>
            <pre class="brush: clojure;">
            (def s (conj '() 1 2 3))
            ;= #'user/s
            s
            ;= (3 2 1)
            
            (peek s)
            ;= 3
            
            (pop s)
            ;= (2 1)
            </pre>
        </div>

        <div id="Set" class="step slide" data-x="2720" data-y="-100">
            <h1>Set</h1>
            <pre class="brush: clojure;">
            (disj #{1 2 3} 3 1)
            ;= #{2}
            </pre>
            <br>
            clojure.set : union, intersection, projection, etc
        </div>

        <div id="Sorted" class="step slide" data-x="2800" data-y="-100">
            <h1>Sorted</h1>
            <pre class="brush: clojure;">
            (def sm (sorted-map 
              :lname "Hickey" :fname "Rich" :age :??))
            ;= #'user/sm
            sm
            ;= {:age :??, :fname "Rich", :lname "Hickey"}
            
            (rseq sm)
            ; ([:lname "Hickey"] [:fname "Rich"] [:age :??])
            
            (subseq sm > :b < :l)
            ;= ([:fname "Rich"])
            </pre>
        </div>

        <div id="fonctionnel1" class="step slide" data-x="2880" data-y="-100">
            <br><br>
            <h1>Clojure encourage la programmation fonctionnelle</h1>
            <br>
            Par définition, une fonction "pure"<br>
            <ul>
                <li>a une valeur de retour qui ne dépend que des arguments passés</li>
                <li>n'a pas d'effet de bord (modification du monde)</li>
                <li>n'a pas de notion de temps</li>
            </ul>
            <br>
            En clojure
            <ul>
                <li>Les fonctions sont des objets de première classe</li>
                <li>La bibliothèque clojure est truffée de fonctions d'ordre supérieur</li>
            </ul>
        </div>

        <div id="Map1" class="step slide" data-x="2960" data-y="-100">
            <h1>Map<br><br><br><img src="img/map.png" width="50%"></h1>
            <pre class="brush: clojure;">
            (map #(+ 10 %1) [ 1 3 5 7 ])
            ;= (11 13 15 17)
            </pre>
            <br>
            (http://techbehindtech.com/)
        </div>

        <div id="Reduce1" class="step slide" data-x="3040" data-y="-100">
            <h1>Reduce<br><br><br><img src="img/reduce.png" width="50%"></h1>
            <pre class="brush: clojure;">
            (reduce * [2 3 4])
            ;= 24
            </pre>
        </div>

        <div id="Filter1" class="step slide" data-x="3120" data-y="-100">
            <h1>Filter<br><br><br><img src="img/filter.png" width="50%"></h1>
            <pre class="brush: clojure;">
            (filter even? [1 2 3 4 5 6])
            ;= (2 4 6)
            </pre>
        </div>

        <div id="Iterate1" class="step slide" data-x="3200" data-y="-100">
            <h1>Iterate</h1>
            <br><br>
            <q>Returns a lazy sequence of x, (f x), (f (f x)) etc.<br>
            f must be free of side-effects</q>
            <br>
            <pre class="brush: clojure;">
            (take 10 (iterate (partial + 2) 0))
            (0 2 4 6 8 10 12 14 16 18)
            </pre>
        </div>

        <div id="Exemple1" class="step slide" data-x="3280" data-y="-100">
            
            <pre class="brush: clojure;">
            
            // http://commons.apache.org/lang/StringUtils
            public static int indexOfAny(String str, 
                                         char[] chars) {
              if (isEmpty(str) 
                  || ArrayUtils.isEmpty(chars)) {
                return -1;
              }
              for (int i = 0; i < str.length(); i++) {
                char ch = str.charAt(i);
                for (int j = 0; j < chars.length; j++) {
                  if (chars[j] == ch) {
                    return i;
                  }
                }
              }
              return -1;
            }
            </pre>
        </div>

        <div id="Exemple2" class="step slide" data-x="3360" data-y="-100">
            <pre class="brush: clojure;">
            (defn indexed [coll]
              (map vector (iterate inc 0) coll))
            
            (defn index-filter [pred coll]
              (for [[idx elt] (indexed coll)
                :when (pred elt)] idx)))
            
            
            ; clojure.core/for
            ; ([seq-exprs body-expr])
            ; Macro
            ;  List comprehension. Takes a vector of one or 
            ;  more binding-form/collection-expr pairs, each
            ;  followed by zero or more modifiers, and yields
            ;  a lazy sequence of evaluations of expr.
            </pre>
            (Stuart Halloway)
        </div>

        <div id="Exemple3" class="step slide" data-x="3440" data-y="-100">
            <br>
            <pre class="brush: clojure;">
            (index-filter #{ \e \i \o \u} "Br  zhC mp urs")
            ;= (11)
            (index-filter #{ \e \i \o \u} "BreizhCampeurs")
            ;= (2 3 7 10 11)
            (index-filter #{2 3 5 7} (range 6))
            ;= (2 3 5)
            (index-filter #(> (.length %) 3)
              ["Bonjour" "les" "BreizhCampeurs" "!"])
            ;= (0 2)
            </pre>
            => la prog fonctionnelle construire la généralisation : lazy-sequence de <b>toutes</b> les correspondances pour un <b>prédicat</b> sur une <b>séquence</b><br>
            <br>
            (~20 méthodes de StringUtils : countMatches, indexOf, indexOfAny, indexOfAnyBut, indexOfIgnoreCase + les mêmes pour last, + nth, etc..)
            <br><br>
            
        </div>

        <div id="Syntaxe3" class="step slide" data-x="3520" data-y="-100">
            <br><br>
            <h1>Lisibilité<br>effort total = effort par line x nombre de lignes</h1>
            <br>
            Le code clojure est plus dense que le code Java (d'un facteur ~10)
            <ul>
                <li>marginalement du fait de la syntaxe ou de petites attentions (with-open..) </li>
                <li>principalement du fait de la généricité des structures de données et des traitements</li>
            </ul>
        </div>

        <div id="fonctionnel4" class="step slide" data-x="3600" data-y="-100">
            
            
            recursive iteration instead of side-effect based looping
            Clojure is impure, in that it doesn't force your program to be referentially transparent, and doesn't strive for 'provable' programs. The philosophy behind Clojure is that most parts of most programs should be functional, and that programs that are more functional are more robust.
            
            
            functionnel non seulement high order function
            mais surtout côté immutabilité que nous verrons un peu plus loin
            
            transparence référentielle exploitée par l'évaluation paresseuse (pas par défaut comme haskell car non pur !), pour la parallélisation, par les méchanismes de synchro, facilite évidemment le test !
            
        </div>

        <div id="fonctionnel5" class="step slide" data-x="3680" data-y="-100">
            <h1>List comprehension</h1>
            
            <pre class="brush: clojure;">
            (take 20 (for [x (range) :when (> (* x x) 3)] (* 2 x)))
            ;= (4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42)
            </pre>
            
        </div>

        <div id="JVM" class="step slide" data-x="3760" data-y="-100">
            <br><br>
            <h1>Un langage sur la JVM</h1>
            <br>
            <ul>
              <li>construit avec et sur l'écosystème</li>
              <li>compilé en bytecode (jamais interpreté), à la volée ou "Ahead Of Time"</li>
              <li>parfaitement intégré au langage Java</li>
            </ul>
        </div>

        <div id="Symbiotique" class="step slide" data-x="3840" data-y="-100">
            <br><br>
            <h1>Construit avec et sur l'écosystème</h1>
            <br>
            <ul>
              <li>toutes les librairies sont accessibles</li>
              <li>les outils de développement, de profilage, de monitoring, </li>
              <li>Les outils et frameworks Clojure ne sont souvent que des surcouches</li>
            </ul>
            <br>
            On ne réécrit pas les drivers JDBC ou les serveurs Web !
        </div>

        <div id="Interopérable" class="step slide" data-x="3920" data-y="-100">
            <br><br>
            <h1>Interopérable avec Java</h1>
            
            <pre class="brush: clojure;">
            (Widget. "red") ; instantiation
            
            (.nextInt rnd) ; appel de méthode
            
            (println Math/PI) ; variable statique
            
            (javax.swing.JOptionPane/showMessageDialog 
              nil "Bonjour BreizhCampeurs !")
              ; méthode statique
            
            </pre>
        </div>

        <div id="Interopérable2" class="step slide" data-x="4000" data-y="-100">
            <h1>Et pour aller (un peu) plus loin</h1>
            <pre class="brush: clojure;">
            (.. person getAdress getZipCode)
              ; accès chainé : moins de () qu'en java !
            
            (def salueur 
              (reify Runnable
                (run [this]
                  (println "Bonjour BreizhCampeurs !"))))
            ;= #'user/salueur
            (.run salueur)
            ; Bonjour BreizhCampeurs !
            ;= nil
            </pre>
            Les map, set, list et vector, respectent les Map, Set, List et Vector Java :-)<br>
            Les fonctions implementent Runnable et Callable
        </div>

        <div id="Interopérable3" class="step slide" data-x="4080" data-y="-100">
            <pre class="brush: clojure;">
            (import '(javax.swing JFrame JPanel JButton 
              JOptionPane) 'java.awt.event.ActionListener)
            
            (def button (JButton. "Click Me!"))
            (def panel (doto (JPanel.)
                         (.add button)))
            (def frame (doto (JFrame. "Hello Frame")
                         (.setSize 200 200)
                         (.setContentPane panel)
                         (.setVisible true)))
            (defn say-hello []
              (JOptionPane/showMessageDialog nil 
                "Hello BreizhCampeurs !" "Greeting" 
                JOptionPane/INFORMATION_MESSAGE))
            
            (.addActionListener button (reify ActionListener
              (actionPerformed [this event] (say-hello))))
            </pre>
        </div>

        <div id="Interopérabilité5" class="step slide" data-x="4160" data-y="-100">
            <br>
            <h1>Interopérabilité : Clojure depuis java</h1>
            <pre class="brush: clojure;">
            (ns calculateur)
            (defn calcule [args]
              (apply + args))
            </pre>
            <pre class="brush: clojure;">
            RT.loadResourceScript("calculateur.clj");
            Object resultat = RT
                .var("calculateur", "calcule")
                .invoke(new int[] {1, 2, 3});
            
            System.out.println(resultat);
            </pre>
        </div>

        <div id="ExpressionProblem" class="step slide" data-x="4240" data-y="-100">
            <br>
            <h1>#1 : Expression Problem<br><br>Comment faciliter l'évolution des programmes<br> par l'ajout de traitement ou de type de données ?</h1>
        </div>

        <div id="ExpressionProblem2" class="step slide" data-x="4320" data-y="-100">
            <br><br><br><br>
            <h1>En langage fonctionnel, il est facile d'ajouter de nouveaux traitements (fonctions) mais difficile d'ajouter de nouveaux types de données<br><br>
            (modification des if/cond/bloc de match qui déterminent le code du traitement à utiliser pour chaque type)</h1>
        </div>

        <div id="ExpressionProblem3" class="step slide" data-x="4400" data-y="-100">
            <br><br><br><br>
            <h1>En langage OO, il est facile d'ajouter de nouveaux types mais difficile d'ajouter des traitements<br><br>
            Le pattern Visiteur n'est qu'une demi-réponse qui nous ramène dans un mode fonctionnel : l'ajout de type nécessite de retoucher les visiteurs</h1>
        </div>

        <div id="Abstractions1" class="step slide" data-x="4480" data-y="-100">
            <h1>Les abstractions de constructions</h1>
            <br>
            Les protocols et les datatypes ont été introduits avec Clojure 1.2 de manière à ce que le langage dispose de ses propres abstractions pour définir ses librairies
            <br><br>
            Avant cela les Sequence, Collection, etc étaient définis en terme d'interface Java et leurs implémentations sous la forme de classe, ce qui rendait le langage dépendant de la plateforme sous-jacente
        </div>

        <div id="Protocol1" class="step slide" data-x="4560" data-y="-100">
            <br><br>
            <ul><li>Le protocole, une sorte d'interface Java</li>
            <pre class="brush: clojure;">
            (defprotocol MonProtocol
              "La doc de mon protocole"
              (bar [a b] "bar docs")
              (baz [a] [a b] [a b c] "baz docs"))
            </pre>
            <br>
            <li>Les "datatypes", des structures de pure donnée</li>
            <pre class="brush: clojure;">
            (defrecord Point [x y]) ; Le POJO clojure..
            </pre>
            </ul>
            
        </div>

        <div id="Protocol2" class="step slide" data-x="4640" data-y="-100">
            <br>
            Le support d'un protocole par un type donné va pouvoir se faire indépendamment de sa déclaration et des autres types supportés
            <br><br>
            <pre class="brush: clojure;">
            (extend-type Point 
              MonProtocol
                (bar [a b] a)
                (baz ([x] x) ([x y & zs] x)))
            </pre>
            <br>
            Ces comportements deviennent pluggables à volonté via extend ou extend-protocol (ou à la déclaration du type)<br><br>
            On peut donc déclarer des ensembles nommés de comportements d'un côté, des types de données de l'autre et les cabler de manière orthogonale
        </div>

        <div id="DataTypes2" class="step slide" data-x="4720" data-y="-100">
            <br>
            Les types de données offre par ailleurs un certain nombre de caractéristiques remarquables : 
            <br><br>
            - respectent l'abstraction Associative pour l'interrogation ou l'ajout de champs
            <pre class="brush: clojure;">
            (:x (Point. 2 3))
            ;= 2
            
            (assoc (Point. 3 4) :z 5)
            ;= #user.Point{:x 3, :y 4, :z 5}
            </pre>
        </div>

        <div id="DataTypes3" class="step slide" data-x="4800" data-y="-100">
            <br><br>
            - sont immutables (more to come..)<br>
            - supportent des méta-données (comme tout le reste..)<br>
            - offre un certain nombre de constructeurs<br>
            - sont Reader-ready :
            <pre class="brush: clojure;">
            user=> (pr-str (Point. 2 3))
            ;= #user.Point{:x 2, :y 3}"
            
            user=> (= (read-string *1) (Point. 2 3))
            ;= true
            </pre>
        </div>

        <div id="Polymorphisme1" class="step slide" data-x="4880" data-y="-100">
            <br>
            <h1>#2 Polymorphisme<br><br>"Utiliser le même code avec différents types" (Wikipedia)</h1>
            On connait en Java, trois formes de polymorphismes intégrés au langage :
            <ul>
              <li>surcharge d'une méthode (types différents des paramètres)</li>
              <li>redéfinition de comportements dans une hierarchie de classes</li>
              <li>classes paramétrées, réalisées pour différents types</li>
            </ul>
            <br>
            => l'appel des méthodes est homogène et le routage de l'appel se base sur le type de l'objet sous-jacent.
        </div>

        <div id="Defmulti1" class="step slide" data-x="4960" data-y="-100">
            <h1>Clojure généralise le principe..<br>.. en explicitant la fonction de répartition</h1>
            Multi-méthode = f° de répartition + n [valeur, f° de traitement]
            <br>
            <pre class="brush: clojure;">
            (defmulti calcul
              (fn [v] (if (<= (count v) 1000)
                :direct :parallel))) 
            
            (defmethod calcul :direct [v]
              (Thread/sleep 10) (reduce + v)) ; long !
            (defmethod calcul :parallel [v]
              (calcul (pmap calcul (partition 1000 v))))
            </pre>
        </div>

        <div id="Defmulti2" class="step slide" data-x="5040" data-y="-100">
            <br>
            <h1>.. en permettant la création de hierarchies adhoc</h1>
            <pre class="brush: clojure;">
            (def h (atom (-> (make-hierarchy)
              (derive java.util.Map ::collection)
              (derive java.util.Collection ::collection))))
            
            (defmulti foo class 
              :default :a-what?
              :hierarchy h)
            
            (defmethod foo ::collection [c] :a-collection)
            (defmethod foo Integer [i] :an-integer)
            (defmethod foo String [s] :a-string)
            </pre>
        </div>

        <div id="Defmulti3" class="step slide" data-x="5120" data-y="-100">
            <br>
            <h1>.. en permettant des dispatchs composites</h1>
            <br>
            <pre class="brush: clojure;">
            (defmulti service-charge
              (fn [acct] [(:account-level acct) (:tag acct)]))
            
            (defmethod service-charge
              [:acc/Basic :acc/Checking]   [_] 25)
            (defmethod service-charge
              [:acc/Basic :acc/Savings]    [_] 10)
            (defmethod service-charge
              [:acc/Premium :acc/Account] [_] 0) 
            </pre>
        </div>

        <div id="Defmulti4" class="step slide" data-x="5200" data-y="-100">
            <div class="centered">All together : defrecord + defmulti</div>
            <pre class="brush: clojure;">
            (defrecord Rectangle [longueur largeur])
            (defrecord Cercle [rayon])
            
            (defmulti surface type)
            (defmethod surface Rectangle [r]
                (* (:longueur r) (:largeur r)))
            (defmethod surface Cercle [c]
                (* (. Math PI) (* (:rayon c) (:rayon c))))
            (defmethod surface :default [x] :oops!)
            
            (surface (Rectangle. 4 13))
            ;= 52
            (surface (Cercle. 4))
            ;= 50.26548245743669
            (surface nil)
            :oops!
            </pre>
            
        </div>

        <div id="Impur" class="step slide" data-x="5280" data-y="-100">
            <br>
            <h1>Fonctionnel impur</h1>
            Peu de programmes sont "fonctionnels", plutôt des process :
            <br>
            <ul>
              <li>avec des effets de bord</li>
              <li>avec état (mémoire ou base de données)</li>
            <ul>
            <br>
            => amène la question du "temps" et différentes réponses à des différents "moments".
            <br><br>
            => remodéliser et gérer le temps dans un contexte muti-thread.
        </div>

        <div id="Variable" class="step slide" data-x="5360" data-y="-100">
            <h1>Autrefois..</h1>
            <br>
            Le modèle traditionnel de la variable était adapté dans un contexte mono-thread où le "temps" était représenté par le flux d'exécution du code.
            <br><br>
            Avec plusieurs threads, il n'y a plus de sequence d'exécution, plus de maitrise de l'emplacement d'une instruction dans le temps en regard des états que va prendre une variable.
            <br><br> 
            => synchronisation manuelle, locks, AtomicLong
            => difficile, fragile
        </div>

        <div id="Identité" class="step slide" data-x="5440" data-y="-100">
            <h1>Tada !!</h1>
            L'approche concurrentielle de Clojure est caractérisée par le concept d'identité, qui représente une série d'états immuables dans le temps.
            <br><br>
            Comme les états sont des valeurs fixes, un nombre indéfini de threads peut les consulter en parallèle<br>
            gérer la concurrence c'est gérer les changements d'un état à un autre.<br>
            <br>
            Dans cette optique, Clojure propose plusieurs types de références mutables, chacun d'eux ayant une sémantique bien définie pour la transition inter-état.
        </div>

        <div id="Concept1" class="step slide" data-x="5520" data-y="-100">
            <br><br>
            <h1>La Valeur</h1>
            <br><br>
            42, une date, une collection.<br>
            Une valeur est immutable
            
        </div>

        <div id="Concept2" class="step slide" data-x="5600" data-y="-100">
            <br>
            <h1>L'identité</h1>
            <br>
            Une entité logique l'on associe a une série de valeur (d'état) liés dans le temps.
            <br><br>
            
            <br>
            <ul>
              <li>Pas un nom ! Une identity peut avoir plusieurs nom. J'appelle ma mère maman, vous l'appelez madame pineau !</li>
              <li>Monnaie : le franc, puis l'euro, bientôt le franc ? Juste une valeur de l'identité monnaie.</li>
              <li>Peut-être composée. L'identité gvt a pris une nouvelle valeur du fait des élections</li>
            <ul>
        </div>

        <div id="Concept3" class="step slide" data-x="5680" data-y="-100">
            <br>
            <h1>L'état</h1>
            <br>
            "State is a value of an identity at a time"
            <br><br><br>
            Il en découle :
            <ul>
              <li>ce qui gère le temps doit faire ref à des valeurs</li>
              <li>le temps est réprésenté par les changements d'état, piloté par un ensemble d'outils</li>
            </ul>
        </div>

        <div id="Immutabilité" class="step slide" data-x="5760" data-y="-100">
            <h1>Immutabilité</h1>
            <br>
            "Things don't change in place."
            <br><br><br>
            Ne pas oublier la dimension temps : x/y/z et t !<br>
            Emplacement memoire et t !<br><br>
            
            t étant la séquence de fonctions de changements d'état, le futur est fonction du passé mais ne le chnage pas.
            <br><br>
            => Tout devrait être immutable : les objets également !
        </div>

        <div id="Marche1" class="step slide" data-x="5840" data-y="-100">
            <div class="centered">Marche athlétique</div>
            <br>
            <div class="centered">
                <img src="img/marche.png">
            </div>
            <div class="centered">"Un pied au moins doit être en permanence en contact avec le sol tandis que la jambe de soutien doit être droite (pas pliée au genou) depuis le moment où le pied touche le sol jusqu'à ce qu'elle passe au-dessous du corps"</div>
        </div>

        <div id="Marche2" class="step slide" data-x="5920" data-y="-100">
            <h1>En java</h1>
            <br>
            reférence directe sur les jambes du marcheur<br>
            lock (stop the world !) pour avoir les positions des deux simultanément.<br>
            <br>
            <div class="centered">
                <img src="img/variables.png">
            </div>
        </div>

        <div id="Marche3" class="step slide" data-x="6000" data-y="-100">
            <h1>En clojure</h1>
            <br>
            reférence indirecte<br>
            prise d'un snapshot (un état) par déréférencement.<br>
            L'état est une value, immutable.<br>
            Je suis hors du temps pour détecter la faute<br>
            <br>
            <div class="centered">
                <img src="img/refs.png">
            </div>
        </div>

        <div id="Concretement1" class="step slide" data-x="6080" data-y="-100">
            <h1>Concrètement</h1>
            <br><br>
            4 types de références mutables en clojure :
            <ul>
              <li>refs : partagé/synchrone/coordonné</li>
              <li>agents : partagé/asynchrone/autonome</li>
              <li>atoms : partagé/synchrone/autonome</li>
              <li>vars : les modifications ne sont visibles que du même thread</li>
            </ul>
        </div>

        <div id="Concretement2" class="step slide" data-x="6160" data-y="-100">
            <h1>Concrètement</h1>
            <br><br>
            Un modèle uniforme de changement d'état :
            <pre class="brush: clojure;">
            ('change-state' ref function [args*])
            </pre>
            <br>
            <ul>
              <li>la fonction recoit l'état courant (en plus des args) et retourne l'état suivant</li>
              <li>snapshot de l'état courant tojours dispo avec deref</li>
              <li>pas de user locks, pas de deadlocks</li>
            </ul>
        </div>

        <div id="Refs1" class="step slide" data-x="6240" data-y="-100">
            <h1>Refs</h1>
            <br>
            <ul>
              <li>Modifié via le Software Transactional Memory, ACI !</li>
              <li>via une transaction : (dosync ..)</li>
              <li>spéculative (rejoue la fonction si conflit)</li>
            </ul>
            
        </div>

        <div id="Refs2" class="step slide" data-x="6320" data-y="-100">
            <pre class="brush: clojure;">
            (def foo (ref {:me "jane", :you "?"}))
            ;= #'user/foo
            @foo
            ;= {:me "jane", :you "?"}
            
            (assoc @foo :you "tar-zan")
            ;= {:me "jane", :you "tar-zan"}
            @foo
            ;= {:me "jane", :you "?"}
            
            (commute foo assoc :you "tar-zan")
            ;= IllegalStateException No transaction running
            
            (dosync (commute foo assoc :you "tar-zan"))
            ;= {:me "jane", :you "tar-zan"}
            @foo
            ;= {:me "jane", :you "tar-zan"}
            </pre>
        </div>

        <div id="Agents" class="step slide" data-x="6400" data-y="-100">
            <h1>Agents</h1>
            Les actions envoyés sont mis en queue
            <pre class="brush: clojure;">
            (def foo (agent {:me "jane", :you "?"}))
            ;= #'user/foo
            
            (send foo assoc :you "tar-zan")
            ;= #&lt;Agent@20d9896e&gt;
            @foo
            ;= {:me "jane", :you "?"}
            
            ; ... plus tard ...
            
            user=> @foo
            {:me "jane", :you "tar-zan"}
            </pre>
        </div>

        <div id="Atoms" class="step slide" data-x="6480" data-y="-100">
            <h1>Atoms</h1>
            <br>
            Garantie d'atomicité sur les modifications
            <pre class="brush: clojure;">
            (def foo (atom {:me "jane", :you "?"}))
            #'user/foo
            user=> (swap! foo assoc :you "tar-zan") 
            {:me "jane", :you "tar-zan"}
            </pre>
            <br>
            Ici aussi une mise à jour spéculative, la fonction peut-être appelée plusieurs fois.
        </div>

        <div id="Vars1" class="step slide" data-x="6560" data-y="-100">
            <h1>Vars</h1>
            <br>
            Ce sont tout simplement les entrées des espaces de nommages, : une correspondance entre un nom et une instance d'un des types vus : fonction, int, atom, etc<br>
            <pre class="brush: clojure;">
            (def foo {:me "jane", :you "?"})
            #'user/foo
            </pre>
        </div>

        <div id="Vars2" class="step slide" data-x="6640" data-y="-100">
            <h1>Vars</h1>
            <br>
            Elles offrent cependant un méchanisme utile en multi-thread : le bindings par thread (et en pile) :
            <pre class="brush: clojure;">
            (def ^:dynamic *foo* {:me "jane", :you "?"})
            ;= #'user/*foo*
            (binding [*foo* {:me "jane", :you "tar-zan"}]
              (doto (Thread. #(println "not bound :" *foo*))
                    .start .join)
               *foo*)
            ; not bound : {:me jane, :you ?}
            ;= {:me "jane", :you "tar-zan"}
            foo
            ;= {:me "jane", :you "?"}
            </pre>
        </div>

        <div id="Résumé1" class="step slide" data-x="6720" data-y="-100">
            <h1>En Résumé</h1>
            <ul>
              <li>Les valeurs immutables
                <ul>
                  <li>une notion typiquement fonctionnelle</li>
                  <li>s'avère aussi précieuse pour la gestion de la concurrence</li>
                </ul>
              </li>
              <li>des structures de données persistentes pour avoir des valeurs composites immutables</li>
            </ul>
        </div>

        <div id="Résumé2" class="step slide" data-x="6800" data-y="-100">
            <h1>En Résumé</h1>
            <br><br>
            Un assortiment de méchanismes de synchronisation des accès en écriture<br>
            L'accès en lecture n'est jamais bloqué<br>
            <br><br>
            <div class="centered"><big>no user locking, no deadlock !</big></div>
        </div>

        <div id="Parallelisme1" class="step slide" data-x="6880" data-y="-100">
            <h1>Parallelisme</h1>
            <br>
            On a vu (furtivement) pmap mais il existe d'autres mécanismes abstrayant la distribution de calculs sur plusieurs threads :
            <pre class="brush: clojure;">
            (pmap + [1 1] [2 2]) 
            ;= (3 3)
            (pvalues (+ 1 2) (+ 1 2))
            ;= (3 3)
            (pcalls #(+ 1 2) #(+ 1 2))
            ;= (3 3)
            </pre>
        </div>

        <div id="Parallelisme2" class="step slide" data-x="6960" data-y="-100">
            <pre class="brush: clojure;">
            (def d (delay (println "Running...") :done!))
            ;= #'user/d ; 
            (@d) ; réalisé à la consommation
            ; Running...
            ;= :done!
            
            (def f (future
              (Thread/sleep 5000) :done! 1000 :troplong!))
            ;= #'user/f
            f ; s'exécute dès son création
            ;= #&lt;core$future@1b0c6cfc: :pending&gt;
            f
            ;= #&lt;core$future@1b0c6cfc: :troplong!&gt;
            @f
            ;= :troplong!
            </pre>
        </div>

        <div id="Outils" class="step slide" data-x="7040" data-y="-100">
            
            <ul>
              <li>Eclipse : Counterclockwise<br>
            http://http://code.google.com/p/counterclockwise<li>
              <li>Intellij IDEA: LaClojure<br>
            http://plugins.intellij.net/plugin/?id=4050<li>
                <li>NetBeans : Enclojure<br>
            http://enclojure.org/<li>
                <li>Emacs, Vi, ..<li>
            <ul>
            
            <ul>
              <li>Lein : http://leiningen.org/</li>
              <li>https://clojars.org/</li>
            <ul>
        </div>

        <div id="More1" class="step slide" data-x="7120" data-y="-100">
            <h1>Mais encore ?<br><br><big>Clojure n'est pas un langage pour la JVM !</big></h1>
            C'est un langage "hébergé" : JVM, CLR, Javascript, Python, ...
            <br><br><br>
            (ThoughtWorks Technology Radar de mars 2012)<br><br>
            <q>
            "ClojureScript illustrates just how cross-platform the
            core of Clojure really is: they ported the primary parts
            to run on JavaScript."
            </q>
            <br>
            <q>
            "One interesting option afforded by ClojureScript is the ability
            to send data structures à la JSON using ClojureScript as
            the data structure. Because Clojure is a Lisp, this means
            that you can also send “real” code."
            </q>
        </div>

        <div id="More2" class="step slide" data-x="7200" data-y="-100">
            <h1>Mais encore ?<br><br><big>Clojure n'est pas un langage dynamique !</big></h1>
            Bon si.. mais
            <pre class="brush: clojure;">
            (defn len [x] (.length x))
            (defn len2 [^String x] (.length x))
             
            (time (reduce + (map len (repeat 1000000 "asdf"))))
            ; "Elapsed time: 3007.198 msecs"
            (time (reduce + (map len2 (repeat 1000000 "asdf"))))
            ; "Elapsed time: 308.045 msecs"
            </pre>
            et demain (GSOC2012) : <b>Clojure with a type system, as a library.</b><br>
            (https://github.com/frenchy64/typed-clojure)
        </div>

        <div id="Références1" class="step slide" data-x="7280" data-y="-100">
            
            http://clojure.org<br>
            http://clojure.org/cheatsheet<br>
            https://github.com/clojure<br>
            <br>
            <b>Rich Hickey !</b><br>
            http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey<br>
            http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey<br>
            http://www.infoq.com/presentations/Simple-Made-Easy<br>
            http://www.youtube.com/watch?v=rI8tNMsozo0 (Simplicity matters)<br>
            <br>
            Why Clojure (Neal_Ford)
            <br>
            http://en.wikibooks.org/wiki/Clojure_Programming<br>
            <br>
            http://tryclj.com (REPL en ligne avec tutoriel interactif)<br>
            http://4clojure.com (problèmes interactifs)<br>
            <br>
            et beaucoup beaucoup d'autres..
        </div>

        <div id="Références2" class="step slide" data-x="7360" data-y="-100">
            
            <img src="img/clojureprogramming.jpg">
            <img src="img/joyofclojure.jpg">
            
        </div>



        <div id="questions" class="step" data-x="300" data-y="300" data-scale="0.5"
             style="background-image:url(img/clojure-glyph.svg); background-repeat:no-repeat; background-position:center center;">
Clojure solves the same problems that OO solves, but it solves them in different ways.<br><br>
Instead of encapsulation, polymorphism, and inheritance, you have closures, namespaces, pure functions, immutable data, and multimethods.<br><br>
Idiomatic OO gives you a bloated type system with duplicated code hidden away behind encapsulation boundaries and little hope for thread safety.<br><br>
Clojure offers a radical alternative: a lean type system, a rich function library, and language-level concurrency support that is usable by mere mortals.
        </div>


    </div>

    <script src="js/impress.js"></script>
    <script>impress().init();</script>

  </body>

</html>
