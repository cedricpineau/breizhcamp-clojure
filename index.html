<!DOCTYPE html>
<html lang="fr">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=1024" />

    <title>Clojure Kisses</title>
    <meta name="description" content="Les fondements, innovants ou antédiluviens, qui font de Clojure un outil unique sur la JVM ! Kiss after kiss, une présentation des grandes idées et des petites attentions du langage." />
    <meta name="author" content="Cédric Pineau" />

    <link href="css/shCoreDefault.css" rel="stylesheet" type="text/css" /> <!--http://alexgorbatchev.com/pub/sh/current/styles/-->
    <script src="js/shCore.js" type="text/javascript"></script> <!--http://alexgorbatchev.com/pub/sh/current/scripts/-->
    <script src="js/shBrushClojure.js" type="text/javascript"></script>
    <script type="text/javascript">SyntaxHighlighter.all();</script>

    <link href="css/fonts.css" rel="stylesheet" /> <!--http://fonts.googleapis.com/css?family=Open+Sans:regular,semibold,italic,italicsemibold|PT+Sans:400,700,400italic,700italic|PT+Serif:400,700,400italic,700italic-->
    <link href="css/clojure-kisses.less" rel="stylesheet/less" type="text/css" />
    <script src="js/less-1.3.0.min.js" type="text/javascript"></script>
    <link href="img/favicon.png" rel="shortcut icon" />
</head>

<body class="impress-not-supported">

    <div class="fallback-message">
        <p>Your browser <b>doesn't support the features required</b> by impress.js, so you are presented with a simplified version of this presentation.</p>
        <p>For the best experience please use the latest <b>Chrome</b>, <b>Safari</b> or <b>Firefox</b> browser.</p>
    </div>

    <div id="impress">

        <div id="Accroche" class="step slide" data-x="0" data-y="-100">
            <br>
            <div class="centered">
                <img src="img/breizhcamp.png" width="100%">
            </div>
            <br><br>
            <div class="centered">
                Les fondements, innovants ou antédiluviens, qui font de<br> 
                <big><strong>Clojure</strong></big><br>
                un outil unique sur la JVM !<br>
                Les grandes idées et les petites attentions du langage.
            </div>
        </div>

        <div id="Bonjour" class="step slide" data-x="90" data-y="-100">
            <br><br><br><br><br><br><br><br>
            <div class="centered">
                <pre class="brush: clojure;">
                    (println "Bonjour et bienvenus BreizhCampeurs !")
                </pre>
            </div>
        </div>

        <div id="Moi" class="step slide" data-x="180" data-y="-100">
            <img src="img/ouam.png" style="float: right; margin-right: 10px;" width="40%" >
            <br>
            <br>
            <br><br><br><br><br>
            <div style="float: left; margin-left: 30px;">
            #1 Le logiciel libre / Debian<br><br>
            #2 Java / JVM / optimisation<br><br>
            #3 FP / Clojure / (Haskell)<br><br>
            <img src="img/followMe.png" width="20%"> <a href="https://twitter.com/#!/CedricPineau">@CedricPineau</a>
            </div>
            <br><br><br><br><br><br><br><br><br><br><br>
            <div style="float: right; margin-right: -100px;"><img src="img/anteo.jpg" width="80%"></div>
        </div>

        <div id="What1" class="step slide" data-x="270" data-y="-100">
            
            <img src="img/jongleur1.png" width="75%" style="float: right; margin-right: 30px;" >
            
            <br><br><br>
            Clo-<b>What ?</b>
        </div>

        <div id="Rich" class="step slide" data-x="360" data-y="-100">
            <img style="float: right; margin-right: 50px;" src="img/keep-it-simple-stupid.jpg" width="25%">
            <br><br>
            <h1>KISS-ako ?</b></h1>
            <br>
            <img src="img/richHickey.jpg">
            <br>
            <br>
            <div class="centered"><q>"Reducing incidental complexity is a primary focus of Clojure"</q></div>
        </div>

        <div id="Opensource" class="step slide" data-x="450" data-y="-100">
            <br><br>
            <h1><b>Clo-jure</b></h1>
            Un développement ouvert, sous licence Eclipse Public License<br>
            <br>
            70 développeurs sur la release 1.4<br>
            <br>
            Une grosse communauté<br>
            <br>
            <ul>Plusieurs conférences dédiées :
              <li>Clojure/West (San Jose)</li>
              <li>Clojure/Conj (Raleigh)</li>
              <li>Euroclojure (Londres)</li>
              <li>(Sans parler du BreizhCamp 2013 !)</li>
            </ul>
        </div>

        <div id="Promo3" class="step slide" data-x="540" data-y="-100">
            <div class="centered">
            <img src="img/successes.png" width="95%" >
            <br><br>
            http://dev.clojure.org/display/community/Clojure+Success+Stories
            </div>
        </div>

        <div id="Promo4" class="step slide" data-x="630" data-y="-100">
            <br>
            <img src="img/limbes.jpg" width="70%" style="float: left; margin-right: 30px;">
            <div class="centered">
            <br>
            <b>Classement TIOBE</b><br>
            <br><br><br>
            Dans les limbes ..<br>
            <br>
            .. entre les positions ..<br>
            <br>
            .. 51 et 100 !<br>
            <br><br>
            (Avec F#, Go, Groovy, .. ;-))
            </div>
        </div>

        <div id="Promo2" class="step slide" data-x="720" data-y="-100">
            <b>ThoughtWorks Technology Radar</b><br>
            (mars 2012)
            <img src="img/thoughtworks.png" width="70%" style="float: right; margin-top: 20px;">
            <br><br>
            <br><br>
            
        </div>

        <div id="Promo1" class="step slide" data-x="810" data-y="-100">
            <br><br><br>
            <div class="centered">
                <img src="img/uncleBob.png" width="80%" >
            </div>
        </div>

        <div id="What2" class="step slide" data-x="900" data-y="-100">
            
            <img src="img/jongleur2.png" width="75%" style="float: right; margin-right: 30px;" >
            
            <br><br><br>
            Un <b>LISP</b>
        </div>

        <div id="lisp1" class="step slide" data-x="990" data-y="-100">
            <br><br>
            <h1>"Practical LISP on the JVM"</h1>
            <br>
            <ul>
                <li>Une syntaxe à base S-expression,
            une notation préfixée</li>
                <li>Un REPL</li>
                <li>typage dynamique (mais fort)</li>
                <li>fonctionnel impur</li>
            </ul>
        </div>

        <div id="Syntaxe1" class="step slide" data-x="1080" data-y="-100">
            <br><br>
            <h1>Lots of Irritating Superfluous Parenthesis !<br>(mais moins que LISP !)</h1>
            <br>
            <ul>
                <li>LISP aka LISt Processing.<br> Le couple de parenthèses définit une liste.<br><br>
                <li>mais éléments de syntaxe tel que les vecteurs [], les maps {}</li>
                <li>au final pas davantage de tokens de structuration que les autres langages</li>
            </ul>
        </div>

        <div id="Syntaxe2" class="step slide" data-x="1170" data-y="-100">
            <br><br>
            <h1>Pourquoi une notation préfixée ?</h1>
            <ul>
                <li>Une syntaxe régulière, les opérateurs sont des fonctions</li>
                <li>Un nombre d'arguments variables : (+ 1 2 3)</li>
                <li>Pas de casse-tête de priorité d'opérateurs !</li>
            </ul>
            <br>
            <pre class="brush: clojure;">
            (+ (* 2 3) 1) ; 1 + 2 * 3
            ;=> 7
            </pre>
        </div>

        <div id="S-expression1" class="step slide" data-x="1260" data-y="-100">
            <br>
            A l'inverse de nombreux langages, il n'existe pas de "Statement"<br><br>
            Tout est expression dont l'évaluation donne une valeur unique, même les constructions de type if, for, ..<br><br>
            <pre class="brush: clojure;">
            1
            ;= 1
            
            [1 2 3] ; Vecteur
            ;= [1 2 3]
            
            (println "Bonjour et bienvenus BreizhCampeurs !")
            ; Bonjour et bienvenus BreizhCampeurs !
            ;= nil
            
            (+ 1 2)  ; Appel de fonction
            ;= 3
            </pre>
        </div>

        <div id="S-expression2" class="step slide" data-x="1350" data-y="-100">
            <br><br>
            Cette structure régulière facilite l'apprentissage du langage<br>
            <br>
            <pre class="brush: clojure;">
            (def a 1) ; int a = 1;
            ;= #'user/a 
            
            (inc a) ; a++; ou ++a; ou a+=1; ou a+1;
            ;= 2
            
            (if (odd? a) (/ a 2) a) ; a%2 != 0 ? a / 2 : a;
            ;= 1/2
            
            (defn square [x]
              "Met au carré"
              (* x x))
            ;= #'user/square
            </pre>
        </div>

        <div id="homoiconicité" class="step slide" data-x="1440" data-y="-100">
            <br><br>
            <h1>Homoiconicité<br>"Lisp programs are lisp data structures"</h1>
            <br>
            <ul>
                <li>Chaque S-expression est un literal ou une liste</li>
                <li>Facilite la création de mini-langages adaptés aux besoins, les Domain Specific Languages</li>
                <li>Une grand partie du langage est défini à partir de macros !</li>
            </ul>
        </div>

        <div id="Macro1" class="step slide" data-x="1530" data-y="-100">
            <br><br>
            <h1>Exemple de la construction "with-open"</h1>
            <pre class="brush: clojure;">
            (with-open [r (java.io.FileReader. "myfile.txt")] 
              (loop [c (.read r)] 
                (if (not= c -1)
                  (do 
                    (print (char c)) 
                    (recur (.read r))))))
            </pre>
        </div>

        <div id="Macro2" class="step slide" data-x="1620" data-y="-100">
            <br><br>
            <pre class="brush: clojure;">
            (defmacro with-open
              [bindings & body]
              (assert-args
                 (vector? bindings) "binding vector"
                 (even? (count bindings)) "even forms")
              (cond
                (= (count bindings) 0) 
                  `(do ~@body)
                (symbol? (bindings 0)) 
                  `(let ~(subvec bindings 0 2)
                    (try
                      (with-open ~(subvec bindings 2) ~@body)
                    (finally
                      (. ~(bindings 0) close))))
                :else (throw (IllegalArgumentException.
                  "only allows Symbols in bindings"))))
            </pre>
        </div>

        <div id="DSL1" class="step slide" data-x="1710" data-y="-100">
            <div class="centered">DSL : Enlive (HTML templating)</div>
            <br><br>
            <pre class="brush: clojure;">
            (defn home-page []
              (html
            
                [:head
                 (include-css "/static/site.css")
                 [:title *title*]]
            
                [:body 
                 [:a {:href "http://clj-la.org"} 
                  [:img {:id "logo" :src "logo.png"}]]
                 [:div {:class "header"} "Hi " (user-name)]
                 [:h1 *title*]
                 "URL: " [:input {:type "text" :id "url"}]
                 [:button {:id "shorten"} "Shorten"]
                 [:div {:id "short" :class "short"}]]
                 (include-js "/static/site.js")))
            </pre>
        </div>

        <div id="DSL2" class="step slide" data-x="1800" data-y="-100">
            <br><br>
            <h1>DSL : ClojureQL (SQL)</h1>
            <br>
            <pre class="brush: clojure;">
            (with-results [rs (table :customer)]
              (doseq [r rs] (println (:lastname r)))
            
            (conj! (table :customer) {:firstname "Rich"})
            
            (conj! (table :customer)
              [{:firstname "Rich" :lastname "Hickey"}
               {:firstname "Stuart" :lastname "Halloway"}])
            </pre>
        </div>

        <div id="Lisp2" class="step slide" data-x="1890" data-y="-100">
            <br><br>
            <h1>"Practical LISP on the JVM"</h1>
            <br><br>
            <q>
            "Lisp is a programmable programming language."<br>
            John Foderaro, CACM, September 1991<br>
            <br><br>
            "Lisp isn't a language, it's a building material."<br>
            Alan Kay
            </q>
            
        </div>

        <div id="REPL1" class="step slide" data-x="1980" data-y="-100">
            <div class="centered">La Read–Eval–Print Loop<br>Un outil de développement interactif
            <br><br><br>
            <img src="img/REPL.png">
            </div>
            <!--
            <iframe src="http://tryclj.com/" width="100%" height="530">
              <p>Your browser does not support iframes.</p>
            </iframe>
            -->
        </div>

        <div id="REPL2" class="step slide" data-x="2070" data-y="-100">
            <br><br>
            <h1>user=> ??</h1>
            La modularité clojure repose sur l'utilisation d'espaces de nommage
            <br><br>
            <pre class="brush: clojure;">
            (ns ^{:doc "The core Clojure language."
                   :author "Rich Hickey"}
              clojure.core)
            ; <->
            
            (defn require
            ; <->
            
            (defn use
            ; <->
            </pre>
        </div>

        <div id="REPL3" class="step slide" data-x="2160" data-y="-100">
            <br>
            On utilise require et use pour lier ou importer d'autres namespaces.<br>
            clojure.core et java.lang sont importés par défaut
            <pre class="brush: clojure;">
            (def input (java.io.StringReader.
                         "<?xml version=\"1.0\"?>
                          <foo>bar</foo>"))
            
            (require 'clojure.data.xml)
            (clojure.data.xml/parse input)
            ;= #clojure.data.xml.Element{:tag :foo, 
            ;=                           :attrs {},
            ;=                           :content ("bar")}
            
            (require '[clojure.data.xml :as xml])
            (xml/parse input)
            
            (use 'clojure.data.xml)
            (parse input)
            </pre>
        </div>

        <div id="REPL4" class="step slide" data-x="2250" data-y="-100">
            <br><br>
            <h1>Quelques fonctions utiles dans un REPL</h1>
            <pre class="brush: clojure;">
            (doc doc)
            ; -------------------------
            ; clojure.repl/doc
            ; ([name])
            ; Macro
            ;  Prints documentation for a var or special form 
            ;  given its name
            ;= nil
            </pre>
        </div>

        <div id="REPL5" class="step slide" data-x="2340" data-y="-100">
            <br>
            <h1>Quelques fonctions utiles dans un REPL</h1>
            <pre class="brush: clojure;">
            all-ns ; sequence de tous les namespaces
            
            ns-publics ; contenu public d'un namespace
            
            apropos ; recherche par regexp dans les noms
            
            find-doc ; recherche par regexp dans les docs
            
            source ; affiche les sources d'une fonction/macro
            
            pst ; affiche la stacktrace, *e pour la dernière
            
            javadoc ; charge la doc java demandée
            </pre>
            
        </div>

        <div id="Typage" class="step slide" data-x="2430" data-y="-100">
            <br><br>
            <h1>Un typage dynamique à la LISP mais fort à la Java</h1>
            <ul>
            <br>
                <li>Pas de conversion de type implicite à la Javascript/PHP
                <li>Des erreurs de types à l'exécution !</li>
            </ul>
            <br>
            <pre class="brush: clojure;">
            (+ 1 "2")
            ; ClassCastException java.lang.String 
            ; cannot be cast to java.lang.Number
            ; clojure.lang.Numbers.add (Numbers.java:126)
            </pre>
        </div>

        <div id="Types1" class="step slide" data-x="2520" data-y="-100">
            <div class="centered">Quels types ?</div>
            <br>
            <pre class="brush: clojure;">
            \A ; caractères, dont \o41 \u00ff \space, etc
            ;= \A
            "Bonjour BreizhCampeurs !" ; chaînes
            ;= "Bonjour BreizhCampeurs !"
            
            true ; booléens
            ; = true
            
            (+ 1 1/7) ; long, double, bigint/decimal + ratio
            ;= 8/7
            
            :pizza4all ; Keyword
            ;= :pizza4all
            
            (re-find #"\d+" "a123de") ; regexp
            ;= "123"
            
            nil ; équivalent du null java, vaut false 
            ;= nil
            </pre>
        </div>

        <div id="dataStructure1" class="step slide" data-x="2610" data-y="-100">
            <br>
            et un ensemble de structures de données :
            <br><br>
            <pre class="brush: clojure;">
            ; Le vecteur, indexé 
            (get [1 2 3 4] 2)
            ;= 3
            
            ; Map
            ({:name "Clojure", :auteur "Rich Hickey"} :name)
            ;= "Clojure"
            
            ; Set
            (#{ \e \i \o \u} )
            ;= 
            
            ; Une liste (chainée simple)
            (second '( \e \i \o \u))
            ;= \e
            </pre>
        </div>

        <div id="dataStructure2" class="step slide" data-x="2700" data-y="-100">
            <br><br><br><br>
            manipulées au travers de 7 abstractions :
            <br><br>
            <ul>
                <li>Collection</li>
                <li>Sequence</li> 
                <li>Associative</li>
                <li>Indexed</li>
                <li>Stack</li>
                <li>Set</li>
                <li>Sorted</li>
            </ul>
        </div>

        <div id="Collection1" class="step slide" data-x="2790" data-y="-100">
            <h1>Collection</h1>
            Toutes les structures de données clojure sont des collections<br>
            <br>
            <pre class="brush: clojure;">
            (def c (conj [] 1 2 3))
            ;= #'user/c
            c
            ;= [1 2 3]
            
            (count c)
            ;= 3
            
            (conj '(1 2) 3)
            ;= (3 1 2)
            
            (conj [1 2] 3)
            ;= [1 2 3]
            </pre>
        </div>

        <div id="Sequence1" class="step slide" data-x="2880" data-y="-100">
            <br>
            <h1>Sequence, une abstraction essentielle du langage</h1>
            <br>
            Toutes les Collections clojure et Java, les maps Java, les CharSequence (dont String), les Iterable, les Arrays et même nil sont des séquences.<br>
            <br>
            Concrètement un répertoire et un fichier sont des séquences, les enregistrements d'une table de BD forment une séquence<br>
            <br>
            L'intérêt principal des sequences est l'<b>évaluation paresseuse</b>, et les <b>séquences infinies</b>
        </div>

        <div id="Sequence2" class="step slide" data-x="2970" data-y="-100">
            <br><br>
            <pre class="brush: clojure;">
            (cons 3 '(1 2)) ou (cons 3 [1 2])
            ;= (3 1 2)
            
            ; first, second, rest, last, butlast, ..
            
            (defn random-ints [limit]
              (lazy-seq
                (cons (rand-int limit)
                      (random-ints limit))))
            ;= #'user/random-ints
            
            (take 10 (random-ints 50))
            ;= (49 5 2 30 35 27 16 17 6 16)
            </pre>
            <br><br><br>
            http://clojure.org/Sequences
        </div>

        <div id="Associative1" class="step slide" data-x="3060" data-y="-100">
            <div class="centered">Associative</div>
            <br>
            <pre class="brush: clojure;">
            (def m (assoc {} :fname "Rich" :lname "Hickey"))
            ;= #'user/m
            
            (get m :lname) ; ou (m :lname) ou même (:lname m)
            ;= "Hickey"
            
            (get m :age "inconnu")
            ;= "inconnu"
            
            (dissoc m :fname :age)
            ;= {:lname "Hickey"}
            
            (contains? m :fname)
            ;= true  ; !?!
            
            (assoc [1 2 3 4] 2 15)
            ; [1 2 15 4]
            
            ; keys, vals, ..
            </pre>
        </div>

        <div id="Indexed1" class="step slide" data-x="3150" data-y="-100">
            <h1>Indexed</h1>
            <pre class="brush: clojure;">
            (def v [:a :b :c])
            ;= #'user/v
            
            (nth v 2) ; ou (v 2) car v est "Associative" !
            ;= :c
            
            (nth v 3)
            ;= IndexOutOfBoundsException ..
            
            (nth v 3 0) ; possibilité de valeur par défaut
            ;= 0
            
            (get v 3)
            ;= nil
            
            (get :?? 3)
            ;= nil
            </pre>
        </div>

        <div id="Stack" class="step slide" data-x="3240" data-y="-100">
            <h1>Stack</h1>
            <pre class="brush: clojure;">
            (def s (conj '() 1 2 3))
            ;= #'user/s
            s
            ;= (3 2 1)
            
            (peek s)
            ;= 3
            
            (pop s)
            ;= (2 1)
            </pre>
        </div>

        <div id="Set" class="step slide" data-x="3330" data-y="-100">
            <h1>Set</h1>
            <pre class="brush: clojure;">
            (def s #{1 2 3})
            ;= #'user/s
            s
            ;= #{1 2 3}
            
            (disj s 3 1)
            ;= #{2}
            </pre>
            <br><br>
            clojure.set : union, intersection, projection, etc
        </div>

        <div id="Sorted" class="step slide" data-x="3420" data-y="-100">
            <h1>Sorted</h1>
            <pre class="brush: clojure;">
            (def sm (sorted-map 
              :lname "Hickey" :fname "Rich" :age :??))
            ;= #'user/sm
            sm
            ;= {:age :??, :fname "Rich", :lname "Hickey"}
            
            (rseq sm)
            ; ([:lname "Hickey"] [:fname "Rich"] [:age :??])
            
            (subseq sm > :b < :l)
            ;= ([:fname "Rich"])
            </pre>
        </div>

        <div id="fonctionnel1" class="step slide" data-x="3510" data-y="-100">
            <br><br>
            <h1>Clojure encourage la programmation fonctionnelle</h1>
            <br>
            Par définition, une fonction "pure"<br>
            <ul>
                <li>a une valeur de retour qui ne dépend que des arguments passés</li>
                <li>n'a pas d'effet de bord (modification du monde)</li>
                <li>n'a pas de notion de temps</li>
            </ul>
            <br>
            En clojure
            <ul>
                <li>Les fonctions sont des objets de première classe</li>
                <li>La bibliothèque clojure est truffée de fonctions d'ordre supérieur</li>
            </ul>
        </div>

        <div id="Map1" class="step slide" data-x="3600" data-y="-100">
            <h1>Map<br><br><br><br><img src="img/map.png" width="50%"></h1>
            <pre class="brush: clojure;">
            (map #(+ 10 %1) [ 1 3 5 7 ])
            ;= (11 13 15 17)
            </pre>
            <br><br><br>
            (http://techbehindtech.com/)
        </div>

        <div id="Reduce1" class="step slide" data-x="3690" data-y="-100">
            <h1>Reduce<br><br><br><br><img src="img/reduce.png" width="60%"></h1>
            <pre class="brush: clojure;">
            (reduce * [2 3 4])
            ;= 24
            </pre>
        </div>

        <div id="Filter1" class="step slide" data-x="3780" data-y="-100">
            <h1>Filter<br><br><br><br><img src="img/filter.png" width="50%"></h1>
            <pre class="brush: clojure;">
            (filter even? [1 2 3 4 5 6])
            ;= (2 4 6)
            </pre>
        </div>

        <div id="Iterate1" class="step slide" data-x="3870" data-y="-100">
            <h1>Iterate</h1>
            <br><br>
            <q>"Returns a lazy sequence of x, (f x), (f (f x)) etc.<br>
            f must be free of side-effects"</q>
            <br><br>
            <pre class="brush: clojure;">
            (take 10 (iterate (partial + 2) 0))
            (0 2 4 6 8 10 12 14 16 18)
            </pre>
        </div>

        <div id="Exemple1" class="step slide" data-x="3960" data-y="-100">
            <br><br>
            <pre class="brush: clojure;">
            
            // http://commons.apache.org/lang/StringUtils
            public static int indexOfAny(String str, 
                                         char[] chars) {
              if (isEmpty(str) 
                  || ArrayUtils.isEmpty(chars)) {
                return -1;
              }
              for (int i = 0; i < str.length(); i++) {
                char ch = str.charAt(i);
                for (int j = 0; j < chars.length; j++) {
                  if (chars[j] == ch) {
                    return i;
                  }
                }
              }
              return -1;
            }
            </pre>
        </div>

        <div id="Exemple2" class="step slide" data-x="4050" data-y="-100">
            <pre class="brush: clojure;">
            (defn indexed [coll]
              (map vector (iterate inc 0) coll))
            
            (defn index-filter [pred coll]
              (for [[idx elt] (indexed coll)
                :when (pred elt)] idx)))
            
            
            ; clojure.core/for
            ; ([seq-exprs body-expr])
            ; Macro
            ;  List comprehension. Takes a vector of one or 
            ;  more binding-form/collection-expr pairs, each
            ;  followed by zero or more modifiers, and yields
            ;  a lazy sequence of evaluations of expr.
            
            ;Un autre petit exemple au passage :
            (take 9 (for [x (range)
                       :when (> (* x x) 3)] (* 2 x)))
            ;= (4 6 8 10 12 14 16 18 20)
            </pre>
            (Stuart Halloway)
        </div>

        <div id="Exemple3" class="step slide" data-x="4140" data-y="-100">
            <pre class="brush: clojure;">
            (index-filter #{ \e \i \o \u} "Br  zhC mp urs")
            ;= (11)
            (index-filter #{ \e \i \o \u} "BreizhCampeurs")
            ;= (2 3 7 10 11)
            (index-filter #{2 3 5 7} (range 6))
            ;= (2 3 5)
            (index-filter #(> (.length %) 3)
              ["Bonjour" "les" "BreizhCampeurs" "!"])
            ;= (0 2)
            </pre>
            <br><br>
            => la prog fonctionnelle construire la généralisation : lazy-sequence de <b>toutes</b> les correspondances pour un <b>prédicat</b> sur une <b>séquence</b><br>
            <br>
            (~20 méthodes de StringUtils : countMatches, indexOf, indexOfAny, indexOfAnyBut, indexOfIgnoreCase + les mêmes pour last, + nth, etc..)
            <br><br>
            
        </div>

        <div id="Syntaxe3" class="step slide" data-x="4230" data-y="-100">
            <br><br>
            <h1>Lisibilité<br>effort total = effort par line x nombre de lignes</h1>
            <br>
            Le code clojure est plus dense que le code Java (d'un facteur 10)<br>
            <br><br>
            <div class="centered">
            marginalement par la syntaxe<br> ou les petites attentions (with-open..)<br><br>
            principalement par la<br><b>généricité des structures de données et des traitements</b>
            </div>
        </div>

        <div id="Syntaxe4" class="step slide" data-x="4320" data-y="-100">
            <br>
            <h1>"The Kingdom of Nouns"</h1>
            
            Entre applications, nous utilisons de la donnée pure. Pourquoi ne le faisons nous pas à l'intérieur de nos programmes ?<br>
            <br><br>
            Un objet<br><br>
            <ul>
                <li>réinvente la roue again, and again, and again, and..</li> 
                <li>a des méthodes information-specific</li>
                <li>lie la logique externe à cette implémentation au lieu d'utiliser des traitements génériques</li>
                <li>empeche du coup la composition</li>
            </ul>
        </div>

        <div id="fonctionnel3" class="step slide" data-x="4410" data-y="-100">
            <h1>Clojure est donc fonctionnel...<br> mais impur !</h1> 
            <br>
            Il ne force pas à la transparence référencielle, à l'absence d'effets de bord<br>
            <br>
            Cependant :
            <div class="centered">
            <q>"Most parts of most programs should be functional"</q>
            <q>"Programs that are more functional are more robust"</q>
            <br><br>
            </div>
            La transparence référentielle est encouragé car exploitée 
            <ul>
              <li>par l'évaluation paresseuse</li>
              <li>par la parallélisation</li>
              <li>par les méchanismes de synchro</li>
              <li>car elle facilite la lecture, le test, la maintenance !</li>
            </ul>
        </div>

        <div id="What3" class="step slide" data-x="4500" data-y="-100">
            
            <img src="img/jongleur3.png" width="75%" style="float: right; margin-right: 30px;" >
            
            <br><br><br>
            Sur la <b>JVM</b>
        </div>

        <div id="JVM" class="step slide" data-x="4590" data-y="-100">
            <br><br>
            <h1>Construit avec et sur l'écosystème</h1>
            <ul>
              <li>construit avec et sur l'écosystème</li>
              <li>compilé en bytecode (jamais interpreté), à la volée ou "Ahead Of Time"</li>
              <li>parfaitement intégré au langage Java</li>
            </ul>
            <br>
            <ul>
              <li>toutes les librairies sont accessibles</li>
              <li>les outils de développement, de profilage, de monitoring, </li>
              <li>Les outils et frameworks Clojure ne sont souvent que des surcouches</li>
            </ul>
            <br>
            On ne réécrit pas les drivers JDBC ou les serveurs Web !
        </div>

        <div id="Interopérable" class="step slide" data-x="4680" data-y="-100">
            <br><br>
            <h1>Interopérable avec Java</h1>
            
            <pre class="brush: clojure;">
            (Widget. "red") ; instantiation
            
            (.nextInt rnd) ; appel de méthode
            
            (println Math/PI) ; variable statique
            
            (javax.swing.JOptionPane/showMessageDialog 
              nil "Bonjour BreizhCampeurs !")
              ; méthode statique
            
            </pre>
        </div>

        <div id="Interopérable2" class="step slide" data-x="4770" data-y="-100">
            <br>
            <h1>Et pour aller (un peu) plus loin</h1>
            <pre class="brush: clojure;">
            (.. person getAdress getZipCode)
              ; accès chainé : moins de () qu'en java !
            
            (def salueur 
              (reify Runnable
                (run [this]
                  (println "Bonjour BreizhCampeurs !"))))
            ;= #'user/salueur
            (.run salueur)
            ; Bonjour BreizhCampeurs !
            ;= nil
            </pre>
            <br>
            <ul>
              <li>Les map, set, list et vector, respectent les interfaces Map, Set, List et Vector Java :-)</li>
              <li>Les fonctions implementent Runnable et Callable</li>
            </ul>
            <br>
            
        </div>

        <div id="Interopérable3" class="step slide" data-x="4860" data-y="-100">
            <br>
            <pre class="brush: clojure;">
            (import '(javax.swing JFrame JPanel JButton 
              JOptionPane) 'java.awt.event.ActionListener)
            
            (def button (JButton. "Click Me!"))
            (def panel (doto (JPanel.)
                         (.add button)))
            (def frame (doto (JFrame. "Hello Frame")
                         (.setSize 200 200)
                         (.setContentPane panel)
                         (.setVisible true)))
            
            (defn say-hello []
              (JOptionPane/showMessageDialog nil 
                "Hello BreizhCampeurs !" "Greeting" 
                JOptionPane/INFORMATION_MESSAGE))
            
            (.addActionListener button (reify ActionListener
              (actionPerformed [this event] (say-hello))))
            </pre>
        </div>

        <div id="Interopérabilité5" class="step slide" data-x="4950" data-y="-100">
            <br>
            <h1>Interopérabilité : Clojure depuis java</h1>
            <pre class="brush: clojure;">
            (ns calculateur)
            (defn calcule [args]
              (apply + args))
            </pre>
            <pre class="brush: clojure;">
            RT.loadResourceScript("calculateur.clj");
            Object resultat = RT
                .var("calculateur", "calcule")
                .invoke(new int[] {1, 2, 3});
            
            System.out.println(resultat);
            </pre>
        </div>

        <div id="What4" class="step slide" data-x="5040" data-y="-100">
            
            <img src="img/jongleur4.png" width="75%" style="float: right; margin-right: 30px;" >
            
            <br><br><br>
            Axé sur la <b>Concurrence</b>
        </div>

        <div id="Impur" class="step slide" data-x="5130" data-y="-100">
            <br>
            <h1>Le problème</h1>
            Peu de programmes sont "fonctionnels", ce sont des process :
            <ul>
              <li>des effets de bord</li>
              <li>des états (mémoire ou base de données)</li>
              <li>=> notion de "temps" et différentes réponses à différents "moments".</li>
            <ul>
            <br><br><br>
            <div class="centered">
            La gestion des états en mémoire est un casse-tête dans un contexte muti-thread.
            <br><br>
            Clojure aborde cette question sous un angle "nouveau"</div>
        </div>

        <div id="Variable" class="step slide" data-x="5220" data-y="-100">
            <br>
            <h1>Autrefois..</h1>
            <br>
            Le modèle traditionnel de la variable était adapté dans un contexte mono-thread où le "temps" était représenté par le flux d'exécution du code.
            <br><br>
            Avec plusieurs threads, il n'y a plus de sequence d'exécution, plus de maitrise de l'emplacement d'une instruction dans le temps en regard des états que va prendre une variable.
            <br><br> 
            => synchronisation manuelle, locks, AtomicLong
            => difficile, fragile
        </div>

        <div id="Identité" class="step slide" data-x="5310" data-y="-100">
            <br>
            <h1>Tada !!</h1>
            L'approche concurrentielle de Clojure est caractérisée par le concept d'<b>identité</b>, qui représente une <b>série d'états</b> immuables <b>dans le temps</b>.
            <br><br><br><br>
            <div class="centered">Les états sont consultables en parallèle.<br><br>
            Gérer la concurrence,<br>gérer le temps,<br>c'est gérer le passage d'un état à un autre.</div>
            
            <br><br>
        </div>

        <div id="Concept1" class="step slide" data-x="5400" data-y="-100">
            <h1>Trois concepts<br>#1 L'identité</h1>
            <br>
            Une série d'états liés dans le temps.
            <br><br>
            
            <br>
            <ul>
              <li>Pas un nom ! Une identité porte plusieurs noms.<br>J'appelle ma mère maman, vous l'appelez madame Pineau !</li><br>
              <li>Pas stable ! Une succession d'état<br>
            Monnaie en france : le franc, puis l'euro, bientôt le franc ?</li><br>
              <li>Peut-être composée. L'identité gouvernement a pris une nouvelle valeur du fait des élections !</li>
            <ul>
        </div>

        <div id="Concept2" class="step slide" data-x="5490" data-y="-100">
            <br><br>
            <h1>Trois concepts<br>#2 La Valeur</h1>
            <br><br>
            Une valeur est par définition quelque chose d'immuable :<br><br>
            <ul>
              <li>42</li>
              <li>Une date</li>
              <li>Un ensemble de données</li>
            <ul>
        </div>

        <div id="Concept3" class="step slide" data-x="5580" data-y="-100">
            <br><br>
            <h1>Trois concepts<br>#3 L'état</h1>
            <br>
            L'état, c'est la <b>valeur</b> d'une identité à un instant donné
            <br><br><br>
            => ce qui gère le temps doit manipuler des <b>valeurs</b>
        </div>

        <div id="Immutabilité" class="step slide" data-x="5670" data-y="-100">
            <h1>Immutabilité<br>"Things don't change in place."<br>Le futur est fonction du passé mais ne le change pas.</h1>
            
            <br><br>
            <div class="centered">
            => Tous les types clojure vus jusqu'ici sont immuables !
            <br><br><br>
            De manière efficace dans l'espace<br>
            De manière efficace dans le temps
            <br><br>
            (repose sur le partage de sous-structures, possible puisque immuables !)
            </div>
        </div>

        <div id="Marche1" class="step slide" data-x="5760" data-y="-100">
            <div class="centered">Illustration : La marche athlétique</div>
            <br>
            <div class="centered">
                <img src="img/marche.png" height="70%">
            </div>
            <div class="centered">"Un pied au moins doit être en permanence en contact avec le sol tandis que la jambe de soutien doit être droite depuis le moment où le pied touche le sol jusqu'à ce qu'elle passe au-dessous du corps"</div>
        </div>

        <div id="Marche2" class="step slide" data-x="5850" data-y="-100">
            <h1>En java</h1>
            <br>
            Reférence directe sur les jambes du marcheur<br>
            => lock (stop the world !) pour avoir les positions des deux simultanément.<br>
            <br><br>
            <div class="centered">
                <img src="img/variables.png" width="100%">
            </div>
        </div>

        <div id="Marche3" class="step slide" data-x="5940" data-y="-100">
            <h1>En clojure</h1>
            <br>
            Reférence indirecte<br>
            Prise d'un snapshot (un état) par déréférencement.<br><br>
            L'état est une value, immutable.<br>
            Je suis hors du temps pour détecter la faute<br>
            <br><br>
            <div class="centered">
                <img src="img/refs.png" width="100%">
            </div>
        </div>

        <div id="Concretement1" class="step slide" data-x="6030" data-y="-100">
            <br>
            <h1>Concrètement</h1>
            <br><br>
            Clojure propose 4 types de références mutables<br>
            <br><br>
            Chacun avec sa sémantique pour la transition inter-état :
            <ul>
              <li>refs : partagé/synchrone/coordonné</li>
              <li>agents : partagé/asynchrone/autonome</li>
              <li>atoms : partagé/synchrone/autonome</li>
              <li>vars : les modifications ne sont visibles que du même thread</li>
            </ul>
        </div>

        <div id="Concretement2" class="step slide" data-x="6120" data-y="-100">
            <br>
            <h1>Concrètement</h1>
            <br><br>
            Un modèle uniforme de changement d'état :
            <pre class="brush: clojure;">
            ('change-state' ref function [args*])
            </pre>
            <br>
            <ul>
              <li>recoit l'état courant (en + des args) et retourne l'état suivant</li>
              <li>snapshot de l'état courant toujours disponible via deref</li>
              <li>pas de locks</li>
            </ul>
        </div>

        <div id="Refs1" class="step slide" data-x="6210" data-y="-100">
            <div class="centered">Refs</div>
            <br>
            <ul>
              <li>Utilise un Software Transactional Memory (ACI) !</li>
              <li>via une transaction : (dosync ..)</li>
              <li>spéculative (rejoue la fonction si conflit)</li>
            </ul>
            <pre class="brush: clojure;">
            (def foo (ref {:me "jane", :you "?"}))
            ;= #'user/foo
            @foo
            ;= {:me "jane", :you "?"}
            
            (assoc @foo :you "tar-zan")
            ;= {:me "jane", :you "tar-zan"}
            @foo
            ;= {:me "jane", :you "?"}
            
            (commute foo assoc :you "tar-zan")
            ;= IllegalStateException No transaction running
            
            (dosync (commute foo assoc :you "tar-zan"))
            ;= {:me "jane", :you "tar-zan"}
            @foo
            ;= {:me "jane", :you "tar-zan"}
            </pre>
        </div>

        <div id="Agents" class="step slide" data-x="6300" data-y="-100">
            <h1>Agents</h1>
            Les actions envoyés sont mis en queue<br><br>
            <pre class="brush: clojure;">
            (def foo (agent {:me "jane", :you "?"}))
            ;= #'user/foo
            
            (send foo assoc :you "tar-zan")
            ;= #&lt;Agent@20d9896e&gt;
            @foo
            ;= {:me "jane", :you "?"}
            
            ; ... plus tard ...
            
            @foo
            ;= {:me "jane", :you "tar-zan"}
            </pre>
        </div>

        <div id="Atoms" class="step slide" data-x="6390" data-y="-100">
            <h1>Atoms</h1>
            <br>
            Garantie d'atomicité sur les modifications<br><br>
            <pre class="brush: clojure;">
            (def foo (atom {:me "jane", :you "?"}))
            ;= #'user/foo
            
            (swap! foo assoc :you "tar-zan") 
            ;= {:me "jane", :you "tar-zan"}
            </pre>
            <br>
            Ici aussi une mise à jour spéculative, la fonction peut-être appelée plusieurs fois.
        </div>

        <div id="Vars1" class="step slide" data-x="6480" data-y="-100">
            <h1>Vars</h1>
            <br>
            Définissent les entrées des espaces de nommages : la correspondance entre un nom et une instance d'un des types vus : fonction, int, atom, etc<br><br>
            <pre class="brush: clojure;">
            (def foo {:me "jane", :you "?"})
            ;= #'user/foo
            </pre>
            <br>
            Une redéfinition est visible de l'ensemble des threads
        </div>

        <div id="Vars2" class="step slide" data-x="6570" data-y="-100">
            <h1>Vars</h1>
            Elles offrent cependant un méchanisme utile en multi-thread : le binding par thread (et en pile) :
            <br><br>
            <pre class="brush: clojure;">
            (def ^:dynamic *foo* {:me "jane", :you "?"})
            ;= #'user/*foo*
            
            (binding [*foo* {:me "jane", :you "tar-zan"}]
              (doto (Thread. #(println "not bound :" *foo*))
                    .start .join)
               *foo*)
            ; not bound : {:me jane, :you ?}
            ;= {:me "jane", :you "tar-zan"}
            
            foo
            ;= {:me "jane", :you "?"}
            </pre>
        </div>

        <div id="Résumé1" class="step slide" data-x="6660" data-y="-100">
            <br>
            <h1>En Résumé</h1>
            Des valeurs immutables
            <ul>
                  <li>une notion typiquement fonctionnelle</li>
                  <li>qui s'avère précieuse dans la gestion de la concurrence</li>
            </ul>
            <br><br>
            Un assortiment de méchanismes de synchronisation d'écriture<br>
            Un accès en lecture qui n'est jamais bloqué<br>
            <br><br>
            <div class="centered"><big><b>Last but not least :<br>"No user locking, no deadlock !"</b></big></div>
        </div>

        <div id="Résumé2" class="step slide" data-x="6750" data-y="-100">
            <div class="centered"><img src="img/fakerichhickey.jpg" width="90%"></div>
        </div>

        <div id="Parallelisme1" class="step slide" data-x="6840" data-y="-100">
            <br>
            <h1>Parallelisme</h1>
            On a vu (furtivement) pmap mais il existe d'autres mécanismes abstrayant la distribution de calculs sur plusieurs threads :
            <br><br>
            <pre class="brush: clojure;">
            (pmap + [1 1] [2 2]) 
            ;= (3 3)
            
            (pvalues (+ 1 2) (+ 1 2))
            ;= (3 3)
            
            (pcalls #(+ 1 2) #(+ 1 2))
            ;= (3 3)
            </pre>
        </div>

        <div id="Parallelisme2" class="step slide" data-x="6930" data-y="-100">
            <br><br>
            <pre class="brush: clojure;">
            (def d (delay (println "Running...") :done!))
            ;= #'user/d ; 
            (@d) ; réalisé à la consommation
            ; Running...
            ;= :done!
            
            (def f (future
              (Thread/sleep 5000) :done! 1000 :troplong!))
            ;= #'user/f
            f ; s'exécute dès son création
            ;= #&lt;core$future@1b0c6cfc: :pending&gt;
            f
            ;= #&lt;core$future@1b0c6cfc: :troplong!&gt;
            @f
            ;= :troplong!
            </pre>
        </div>

        <div id="What5" class="step slide" data-x="7020" data-y="-100">
            
            <img src="img/jongleur5.png" width="75%" style="float: right; margin-right: 0px;" >
            
            <br><br><br>
            Et l'<b>expréssivité</b>
        </div>

        <div id="ExpressionProblem" class="step slide" data-x="7110" data-y="-100">
            <br><br><br>
            <h1>#1 : "Expression Problem"<br>
            <br><br><br>Comment faciliter l'évolution des programmes<br> par l'ajout de traitement ou de type de données ?</h1>
        </div>

        <div id="ExpressionProblem2" class="step slide" data-x="7200" data-y="-100">
            <br><br><br><br>
            <h1>En langage fonctionnel, il est facile d'ajouter de nouveaux traitements (fonctions) mais difficile d'ajouter de nouveaux types de données<br><br>
            (modification des if/cond/bloc de match qui déterminent le code du traitement à utiliser pour chaque type)</h1>
        </div>

        <div id="ExpressionProblem3" class="step slide" data-x="7290" data-y="-100">
            <br><br><br><br>
            <h1>En langage OO, il est facile d'ajouter de nouveaux types mais difficile d'ajouter des traitements<br><br>
            Le pattern Visiteur n'est qu'une demi réponse qui nous ramène dans un mode fonctionnel : l'ajout de type nécessite de retoucher les visiteurs</h1>
        </div>

        <div id="Abstractions1" class="step slide" data-x="7380" data-y="-100">
            <h1>Les abstractions de constructions</h1>
            <br>
            Les protocols et les datatypes ont été introduits avec Clojure 1.2 de manière à ce que le langage dispose de ses propres abstractions pour définir ses librairies
            <br><br>
            Avant cela les Sequence, Collection, etc étaient définis en terme d'interface Java et leurs implémentations sous la forme de classe, ce qui rendait le langage dépendant de la plateforme sous-jacente
        </div>

        <div id="Protocol1" class="step slide" data-x="7470" data-y="-100">
            <h1>Les abstractions de constructions</h1>
            <br>
            <ul><li>Le protocole, une sorte d'interface Java</li>
            <pre class="brush: clojure;">
            (defprotocol MonProtocol
              "La doc de mon protocole"
              (bar [a b] "bar docs")
              (baz [a] [a b] [a b c] "baz docs"))
            </pre>
            <br><br>
            <li>Les "datatypes", des structures de pures données</li>
            <pre class="brush: clojure;">
            (defrecord Point [x y]) ; Le POJO clojure..
            </pre>
            </ul>
            
        </div>

        <div id="Protocol2" class="step slide" data-x="7560" data-y="-100">
            <br>
            Le support d'un protocole par un type est indépendant de sa déclaration et des autres types supportés par le protocole :
            <br><br>
            <pre class="brush: clojure;">
            (extend-type Point ; extend/extend-protocol
              MonProtocol
                (bar [a b] a)
                (baz ([x] x) ([x y & zs] x)))
            
            (bar (Point. 1 2) :n'imp)
            ;= #user.Point{:x 1, :y 2}
            </pre>
            <br>
            => Clojure permet de déclarer des ensembles nommés de comportements d'un côté, des types de données de l'autre et de cabler le tout de manière orthogonale :<br><br>
            <ul>
            <li>Sans avoir, sans modifier le code du Protocole</li>
            <li>Sans avoir, sans modifier le code du Record</li>
            <br>
        </div>

        <div id="DataTypes2" class="step slide" data-x="7650" data-y="-100">
            Les types de données offre par ailleurs un certain nombre de caractéristiques remarquables : 
            <br><br>
            - ils sont "Associative"
            <pre class="brush: clojure;">
            (:x (Point. 2 3))
            ;= 2
            
            (assoc (Point. 3 4) :z 5)
            ;= #user.Point{:x 3, :y 4, :z 5}
            </pre>
            - ils sont immutables (more to come..)<br>
            - ils supportent des méta-données (comme tout le reste..)<br>
            - ils offrent un certain nombre de constructeurs<br>
            - ils sont Reader-ready :
            <pre class="brush: clojure;">
            user=> (pr-str (Point. 2 3))
            ;= #user.Point{:x 2, :y 3}"
            
            user=> (= (read-string *1) (Point. 2 3))
            ;= true
            </pre>
        </div>

        <div id="Polymorphisme1" class="step slide" data-x="7740" data-y="-100">
            <br>
            <h1>#2 Polymorphisme<br><br>"Utiliser le même code avec différents types" (Wikipedia)</h1>
            On connait en Java, trois formes de polymorphismes intégrés au langage :
            <ul>
              <li>surcharge d'une méthode (types différents des paramètres)</li>
              <li>redéfinition de comportements dans une hierarchie de classes</li>
              <li>classes paramétrées, réalisées pour différents types</li>
            </ul>
            <br>
            => l'appel des méthodes est homogène et le routage de l'appel se base sur le type de l'objet sous-jacent.
            
        </div>

        <div id="Defmulti1" class="step slide" data-x="7830" data-y="-100">
            <br>
            <h1>Clojure généralise le principe..<br>.. en explicitant la fonction de répartition</h1>
            Multi-méthode = f° de répartition + n [valeur, f° de traitement]
            <br><br>
            <pre class="brush: clojure;">
            (defmulti calcul
              (fn [v] (if (<= (count v) 1000)
                :direct :parallel))) 
            
            (defmethod calcul :direct [v]
              (Thread/sleep 10) (reduce + v)) ; long !
            (defmethod calcul :parallel [v]
              (calcul (pmap calcul (partition 1000 v))))
            </pre>
        </div>

        <div id="Defmulti2" class="step slide" data-x="7920" data-y="-100">
            <br><br>
            <h1>.. en permettant la création de hierarchies adhoc</h1>
            <pre class="brush: clojure;">
            (def h (atom (-> (make-hierarchy)
              (derive java.util.Map ::collection)
              (derive java.util.Collection ::collection))))
            
            (defmulti foo class 
              :default :a-what?
              :hierarchy h)
            
            (defmethod foo ::collection [c] :a-collection)
            (defmethod foo Integer [i] :an-integer)
            (defmethod foo String [s] :a-string)
            </pre>
        </div>

        <div id="Defmulti3" class="step slide" data-x="8010" data-y="-100">
            <br><br>
            <h1>.. en permettant des dispatchs composites</h1>
            <br>
            <pre class="brush: clojure;">
            (defmulti service-charge
              (fn [acct] [(:account-level acct) (:tag acct)]))
            
            (defmethod service-charge
              [:acc/Basic :acc/Checking]   [_] 25)
            (defmethod service-charge
              [:acc/Basic :acc/Savings]    [_] 10)
            (defmethod service-charge
              [:acc/Premium :acc/Account] [_] 0) 
            </pre>
        </div>

        <div id="Defmulti4" class="step slide" data-x="8100" data-y="-100">
            <h1>All together !<br> defrecord + defmulti</h1>
            <pre class="brush: clojure;">
            (defrecord Rectangle [longueur largeur])
            (defrecord Cercle [rayon])
            
            (defmulti surface type)
            (defmethod surface Rectangle [r]
                (* (:longueur r) (:largeur r)))
            (defmethod surface Cercle [c]
                (* (. Math PI) (* (:rayon c) (:rayon c))))
            (defmethod surface :default [x] :oops!)
            
            (surface (Rectangle. 4 13))
            ;= 52
            (surface (Cercle. 4))
            ;= 50.26548245743669
            (surface nil)
            :oops!
            </pre>
            
        </div>

        <div id="ThatsAll" class="step slide" data-x="8190" data-y="-100">
            <img src="img/all-folks.jpg" width="100%">
        </div>

        <div id="More1" class="step slide" data-x="8280" data-y="-100">
            <h1>Quoi encore ?<br><br><big>Clojure n'est pas un langage pour la JVM !</big></h1>
            C'est un langage "hébergé" : JVM, CLR, Javascript, Python, ...
            <br><br><br>
            (ThoughtWorks Technology Radar de mars 2012)<br><br>
            <q>
            "ClojureScript illustrates just how cross-platform the
            core of Clojure really is: they ported the primary parts
            to run on JavaScript."
            </q>
            <br>
            <q>
            "One interesting option afforded by ClojureScript is the ability
            to send data structures à la JSON using ClojureScript as
            the data structure. Because Clojure is a Lisp, this means
            that you can also send “real” code."
            </q>
        </div>

        <div id="More2" class="step slide" data-x="8370" data-y="-100">
            <h1>Mais encore ?<br><br><big>Clojure n'est pas un langage dynamique !</big></h1>
            Bon si.. mais
            <pre class="brush: clojure;">
            (defn len [x] (.length x))
            (defn len2 [^String x] (.length x))
             
            (time (reduce + (map len (repeat 1000000 "42"))))
            ; "Elapsed time: 3007.198 msecs"
            (time (reduce + (map len2 (repeat 1000000 "42"))))
            ; "Elapsed time: 308.045 msecs"
            </pre>
            et demain (GSOC2012) : <b>Clojure with a type system, as a library.</b><br>
            (https://github.com/frenchy64/typed-clojure)
        </div>

        <div id="Outils" class="step slide" data-x="8460" data-y="-100">
            <br>
            <h1>Les outils</h1>
            <ul>
              <li>Eclipse : Counterclockwise<br>
            http://http://code.google.com/p/counterclockwise</li>
            <br>
              <li>Intellij IDEA: LaClojure<br>
            http://plugins.intellij.net/plugin/?id=4050</li>
            <br>
                <li>NetBeans : Enclojure<br>
            http://enclojure.org/</li>
            <br>
                <li>Emacs, Vi, ..</li>
            <br>
              <li>Lein : http://leiningen.org/</li>
              <li>https://clojars.org/</li>
            <ul>
        </div>

        <div id="Références1" class="step slide" data-x="8550" data-y="-100">
            <h1>Références</h1>
            
            <div class="centered">
              <img src="img/clojureprogramming.jpg" height="70%">
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <img src="img/joyofclojure.jpg" height="70%">
            </div>
        </div>

        <div id="Références2" class="step slide" data-x="8640" data-y="-100">
            <br><br>
            http://clojure.org<br>
            http://clojure.org/cheatsheet<br>
            https://github.com/clojure<br>
            <br>
            <b>Rich Hickey !</b><br>
            http://infoq.com/presentations/Are-We-There-Yet-Rich-Hickey<br>
            http://infoq.com/presentations/Value-Identity-State-Rich-Hickey<br>
            http://infoq.com/presentations/Simple-Made-Easy<br>
            http://youtube.com/watch?v=rI8tNMsozo0 (Simplicity matters)<br>
            <br>
            Why Clojure (Neal_Ford)
            <br>
            http://en.wikibooks.org/wiki/Clojure_Programming<br>
            <br>
            http://tryclj.com (REPL en ligne avec tutoriel interactif)<br>
            http://4clojure.com (problèmes interactifs)<br>
        </div>



        <div id="questions" class="step" data-x="300" data-y="300">
<img src="img/clojure-glyph.svg" width="30%" style="float: left; margin-right: 30px;"><br>
"Clojure solves the same problems that OO solves, but it solves them in different ways.<br><br>
Instead of encapsulation, polymorphism, and inheritance, you have closures, namespaces, pure functions, immutable data, and multimethods.<br><br>
Idiomatic OO gives you a bloated type system with duplicated code hidden away behind encapsulation boundaries and little hope for thread safety.<br><br>
Clojure offers a radical alternative: a lean type system, a rich function library, and language-level concurrency support that is usable by mere mortals."
        </div>


    </div>

      <img id="kiss1" class="kiss" style="position:fixed; display:none; "src="img/kiss1.png">

    <script src="js/impress.js"></script>
    <script>impress().init();</script>

    <script>

function ShowHide(element) {
   if (!element) return;
   if (element.style.display == "none" ) {
      element.style.display = "" ;
   } else {
      element.style.display = "none" ;
   }
} 

function random(min, max) {
   return Math.round(min + Math.random()*(max - min))
}

document.addEventListener("keyup", function ( event ) {
            if ( event.keyCode === 75 ) {
                switch( event.keyCode ) {
                    case 75: 
                             element = document.getElementById("kiss"+random(1, 1));
                             element.style.top = ""+random(0, 70)+"%";
                             element.style.right = ""+random(0, 70)+"%";
			     ShowHide(element) ;
                             break;
                }
                
                event.preventDefault();
            }
        }, false);
    </script>

  </body>

</html>
