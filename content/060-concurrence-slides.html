
<!--#Impur#-->
<br>
<h1>Fonctionnel impur</h1>
Peu de programmes sont "fonctionnels", plutôt des process :
<br>
<ul>
  <li>avec des effets de bord</li>
  <li>avec état (mémoire ou base de données)</li>
<ul>
<br>
=> amène la question du "temps" et différentes réponses à des différents "moments".
<br><br>
=> remodéliser et gérer le temps dans un contexte muti-thread.
<!--/-->

<!--#Variable#-->
<h1>Autrefois..</h1>
<br>
Le modèle traditionnel de la variable était adapté dans un contexte mono-thread où le "temps" était représenté par le flux d'exécution du code.
<br><br>
Avec plusieurs threads, il n'y a plus de sequence d'exécution, plus de maitrise de l'emplacement d'une instruction dans le temps en regard des états que va prendre une variable.
<br><br> 
=> synchronisation manuelle, locks, AtomicLong
=> difficile, fragile
<!--/-->

<!--#Identité#-->
<h1>Tada !!</h1>
L'approche concurrentielle de Clojure est caractérisée par le concept d'identité, qui représente une série d'états immuables dans le temps.
<br><br>
Comme les états sont des valeurs fixes, un nombre indéfini de threads peut les consulter en parallèle<br>
gérer la concurrence c'est gérer les changements d'un état à un autre.<br>
<br>
Dans cette optique, Clojure propose plusieurs types de références mutables, chacun d'eux ayant une sémantique bien définie pour la transition inter-état.
<!--/-->


<!--#Concept1#-->
<br><br>
<h1>La Valeur</h1>
<br><br>
42, une date, une collection.<br>
Une valeur est immutable

<!--/-->

<!--#Concept2#-->
<br>
<h1>L'identité</h1>
<br>
Une entité logique l'on associe a une série de valeur (d'état) liés dans le temps.
<br><br>

<br>
<ul>
  <li>Pas un nom ! Une identity peut avoir plusieurs nom. J'appelle ma mère maman, vous l'appelez madame pineau !</li>
  <li>Monnaie : le franc, puis l'euro, bientôt le franc ? Juste une valeur de l'identité monnaie.</li>
  <li>Peut-être composée. L'identité gvt a pris une nouvelle valeur du fait des élections</li>
<ul>
<!--/-->

<!--#Concept3#-->
<br>
<h1>L'état</h1>
<br>
"State is a value of an identity at a time"
<br><br><br>
Il en découle :
<ul>
  <li>ce qui gère le temps doit faire ref à des valeurs</li>
  <li>le temps est réprésenté par les changements d'état, piloté par un ensemble d'outils</li>
</ul>
<!--/-->


<!--#Immutabilité#-->
<h1>Immutabilité</h1>
<br>
"Things don't change in place."
<br><br><br>
Ne pas oublier la dimension temps : x/y/z et t !<br>
Emplacement memoire et t !<br><br>

t étant la séquence de fonctions de changements d'état, le futur est fonction du passé mais ne le chnage pas.
<br><br>
=> Tout devrait être immutable : les objets également !
<!--/-->


<!--#Marche1#-->
<div class="centered">Marche athlétique</div>
<br>
<div class="centered">
    <img src="img/marche.png">
</div>
<div class="centered">"Un pied au moins doit être en permanence en contact avec le sol tandis que la jambe de soutien doit être droite (pas pliée au genou) depuis le moment où le pied touche le sol jusqu'à ce qu'elle passe au-dessous du corps"</div>
<!--/-->

<!--#Marche2#-->
<h1>En java</h1>
<br>
reférence directe sur les jambes du marcheur<br>
lock (stop the world !) pour avoir les positions des deux simultanément.<br>
<br>
<div class="centered">
    <img src="img/variables.png">
</div>
<!--/-->

<!--#Marche3#-->
<h1>En clojure</h1>
<br>
reférence indirecte<br>
prise d'un snapshot (un état) par déréférencement.<br>
L'état est une value, immutable.<br>
Je suis hors du temps pour détecter la faute<br>
<br>
<div class="centered">
    <img src="img/refs.png">
</div>
<!--/-->

<!--#Concretement1#-->
<h1>Concrètement</h1>
<br><br>
4 types de références mutables en clojure :
<ul>
  <li>refs : partagé/synchrone/coordonné</li>
  <li>agents : partagé/asynchrone/autonome</li>
  <li>atoms : partagé/synchrone/autonome</li>
  <li>vars : les modifications ne sont visibles que du même thread</li>
</ul>
<!--/-->

<!--#Concretement2#-->
<h1>Concrètement</h1>
<br><br>
Un modèle uniforme de changement d'état :
<pre class="brush: clojure;">
('change-state' ref function [args*])
</pre>
<br>
<ul>
  <li>la fonction recoit l'état courant (en plus des args) et retourne l'état suivant</li>
  <li>snapshot de l'état courant tojours dispo avec deref</li>
  <li>pas de user locks, pas de deadlocks</li>
</ul>
<!--/-->

<!--#Refs1#-->
<h1>Refs</h1>
<br>
<ul>
  <li>Modifié via le Software Transactional Memory, ACI !</li>
  <li>via une transaction : (dosync ..)</li>
  <li>spéculative (rejoue la fonction si conflit)</li>
</ul>

<!--/-->

<!--#Refs2#-->
<pre class="brush: clojure;">
(def foo (ref {:me "jane", :you "?"}))
;= #'user/foo
@foo
;= {:me "jane", :you "?"}

(assoc @foo :you "tar-zan")
;= {:me "jane", :you "tar-zan"}
@foo
;= {:me "jane", :you "?"}

(commute foo assoc :you "tar-zan")
;= IllegalStateException No transaction running

(dosync (commute foo assoc :you "tar-zan"))
;= {:me "jane", :you "tar-zan"}
@foo
;= {:me "jane", :you "tar-zan"}
</pre>
<!--/-->

<!--#Agents#-->
<h1>Agents</h1>
Les actions envoyés sont mis en queue
<pre class="brush: clojure;">
(def foo (agent {:me "jane", :you "?"}))
;= #'user/foo

(send foo assoc :you "tar-zan")
;= #&lt;Agent@20d9896e&gt;
@foo
;= {:me "jane", :you "?"}

; ... plus tard ...

user=> @foo
{:me "jane", :you "tar-zan"}
</pre>
<!--/-->

<!--#Atoms#-->
<h1>Atoms</h1>
<br>
Garantie d'atomicité sur les modifications
<pre class="brush: clojure;">
(def foo (atom {:me "jane", :you "?"}))
#'user/foo
user=> (swap! foo assoc :you "tar-zan") 
{:me "jane", :you "tar-zan"}
</pre>
<br>
Ici aussi une mise à jour spéculative, la fonction peut-être appelée plusieurs fois.
<!--/-->

<!--#Vars1#-->
<h1>Vars</h1>
<br>
Ce sont tout simplement les entrées des espaces de nommages, : une correspondance entre un nom et une instance d'un des types vus : fonction, int, atom, etc<br>
<pre class="brush: clojure;">
(def foo {:me "jane", :you "?"})
#'user/foo
</pre>
<!--/-->

<!--#Vars2#-->
<h1>Vars</h1>
<br>
Elles offrent cependant un méchanisme utile en multi-thread : le bindings par thread (et en pile) :
<pre class="brush: clojure;">
(def ^:dynamic *foo* {:me "jane", :you "?"})
;= #'user/*foo*
(binding [*foo* {:me "jane", :you "tar-zan"}]
  (doto (Thread. #(println "not bound :" *foo*))
        .start .join)
   *foo*)
; not bound : {:me jane, :you ?}
;= {:me "jane", :you "tar-zan"}
foo
;= {:me "jane", :you "?"}
</pre>
<!--/-->

<!--#Résumé1#-->
<h1>En Résumé</h1>
<ul>
  <li>Les valeurs immutables
    <ul>
      <li>une notion typiquement fonctionnelle</li>
      <li>s'avère aussi précieuse pour la gestion de la concurrence</li>
    </ul>
  </li>
  <li>des structures de données persistentes pour avoir des valeurs composites immutables</li>
</ul>
<!--/-->

<!--#Résumé2#-->
<h1>En Résumé</h1>
<br><br>
Un assortiment de méchanismes de synchronisation des accès en écriture<br>
L'accès en lecture n'est jamais bloqué<br>
<br><br>
<div class="centered"><big>no user locking, no deadlock !</big></div>
<!--/-->


<!--#Parallelisme1#-->
<h1>Parallelisme</h1>
<br>
On a vu (furtivement) pmap mais il existe d'autres mécanismes abstrayant la distribution de calculs sur plusieurs threads :
<pre class="brush: clojure;">
(pmap + [1 1] [2 2]) 
;= (3 3)
(pvalues (+ 1 2) (+ 1 2))
;= (3 3)
(pcalls #(+ 1 2) #(+ 1 2))
;= (3 3)
</pre>
<!--/-->

<!--#Parallelisme2#-->
<pre class="brush: clojure;">
(def d (delay (println "Running...") :done!))
;= #'user/d ; 
(@d) ; réalisé à la consommation
; Running...
;= :done!

(def f (future
  (Thread/sleep 5000) :done! 1000 :troplong!))
;= #'user/f
f ; s'exécute dès son création
;= #&lt;core$future@1b0c6cfc: :pending&gt;
f
;= #&lt;core$future@1b0c6cfc: :troplong!&gt;
@f
;= :troplong!
</pre>
<!--/-->


==


promises













